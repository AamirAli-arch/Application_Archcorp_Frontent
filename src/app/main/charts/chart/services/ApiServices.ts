/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterUserRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginUserRequest | undefined): Observable<LoginUserResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginUserResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginUserResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginUserResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = LoginUserResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginUserResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequest | undefined): Observable<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ChangePasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ChangePasswordResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordResponse>(<any>null);
    }
}

@Injectable()
export class DepartmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    departments(): Observable<GetDepartmentsResponse> {
        let url_ = this.baseUrl + "/api/Department/Departments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDepartments(<any>response_);
                } catch (e) {
                    return <Observable<GetDepartmentsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDepartmentsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDepartments(response: HttpResponseBase): Observable<GetDepartmentsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDepartmentsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetDepartmentsResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDepartmentsResponse>(<any>null);
    }

    /**
     * @param departmentId (optional) 
     * @return Success
     */
    designationsWithEmployees(departmentId: number | undefined): Observable<DesignationsWithEmployeesResponse> {
        let url_ = this.baseUrl + "/api/Department/DesignationsWithEmployees?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDesignationsWithEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDesignationsWithEmployees(<any>response_);
                } catch (e) {
                    return <Observable<DesignationsWithEmployeesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DesignationsWithEmployeesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDesignationsWithEmployees(response: HttpResponseBase): Observable<DesignationsWithEmployeesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DesignationsWithEmployeesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = DesignationsWithEmployeesResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DesignationsWithEmployeesResponse>(<any>null);
    }
}

@Injectable()
export class EmployeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    employeesForAttendanceReport(): Observable<GetEmployeeForAttendanceResponse> {
        let url_ = this.baseUrl + "/api/Employee/EmployeesForAttendanceReport";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeesForAttendanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeesForAttendanceReport(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeForAttendanceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeForAttendanceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeesForAttendanceReport(response: HttpResponseBase): Observable<GetEmployeeForAttendanceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeForAttendanceResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetEmployeeForAttendanceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeForAttendanceResponse>(<any>null);
    }
}

@Injectable()
export class LeaveClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apply(body: ApplyLeaveRequest | undefined): Observable<ApplyLeaveResponse> {
        let url_ = this.baseUrl + "/api/Leave/Apply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApply(<any>response_);
                } catch (e) {
                    return <Observable<ApplyLeaveResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplyLeaveResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApply(response: HttpResponseBase): Observable<ApplyLeaveResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyLeaveResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApplyLeaveResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplyLeaveResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body: ApproveLeaveRequest | undefined): Observable<ApproveLeaveResponse> {
        let url_ = this.baseUrl + "/api/Leave/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<ApproveLeaveResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApproveLeaveResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<ApproveLeaveResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproveLeaveResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApproveLeaveResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproveLeaveResponse>(<any>null);
    }

    /**
     * @param leaveId (optional) 
     * @return Success
     */
    detail(leaveId: number | undefined): Observable<LeaveDetailResponse> {
        let url_ = this.baseUrl + "/api/Leave/Detail?";
        if (leaveId === null)
            throw new Error("The parameter 'leaveId' cannot be null.");
        else if (leaveId !== undefined)
            url_ += "leaveId=" + encodeURIComponent("" + leaveId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetail(<any>response_);
                } catch (e) {
                    return <Observable<LeaveDetailResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveDetailResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDetail(response: HttpResponseBase): Observable<LeaveDetailResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveDetailResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = LeaveDetailResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveDetailResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeLeaveApplications(body: GetEmployeeLeaveApplicationRequest | undefined): Observable<GetEmployeeLeaveApplicationResponse> {
        let url_ = this.baseUrl + "/api/Leave/EmployeeLeaveApplications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeLeaveApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeLeaveApplications(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeLeaveApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeLeaveApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeLeaveApplications(response: HttpResponseBase): Observable<GetEmployeeLeaveApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeLeaveApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetEmployeeLeaveApplicationResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeLeaveApplicationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeTimeOffApplications(body: GetEmployeeTimeOffApplicationRequest | undefined): Observable<GetEmployeeTimeOffApplicationResponse> {
        let url_ = this.baseUrl + "/api/Leave/EmployeeTimeOffApplications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeTimeOffApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeTimeOffApplications(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeTimeOffApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeTimeOffApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeTimeOffApplications(response: HttpResponseBase): Observable<GetEmployeeTimeOffApplicationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeTimeOffApplicationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetEmployeeTimeOffApplicationResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeTimeOffApplicationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    timeOff(body: ApplyTimeOffRequest | undefined): Observable<ApplyTimeOffResponse> {
        let url_ = this.baseUrl + "/api/Leave/TimeOff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimeOff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimeOff(<any>response_);
                } catch (e) {
                    return <Observable<ApplyTimeOffResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplyTimeOffResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTimeOff(response: HttpResponseBase): Observable<ApplyTimeOffResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyTimeOffResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApplyTimeOffResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplyTimeOffResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveTimeOff(body: ApproveTimeOffRequest | undefined): Observable<ApproveTimeOffResponse> {
        let url_ = this.baseUrl + "/api/Leave/ApproveTimeOff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveTimeOff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveTimeOff(<any>response_);
                } catch (e) {
                    return <Observable<ApproveTimeOffResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApproveTimeOffResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveTimeOff(response: HttpResponseBase): Observable<ApproveTimeOffResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproveTimeOffResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApproveTimeOffResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproveTimeOffResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectTimeOff(body: RejectTimeOffRequest | undefined): Observable<RejectTimeOffResponse> {
        let url_ = this.baseUrl + "/api/Leave/RejectTimeOff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectTimeOff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectTimeOff(<any>response_);
                } catch (e) {
                    return <Observable<RejectTimeOffResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RejectTimeOffResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRejectTimeOff(response: HttpResponseBase): Observable<RejectTimeOffResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RejectTimeOffResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RejectTimeOffResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RejectTimeOffResponse>(<any>null);
    }
}

@Injectable()
export class LeaveBankClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param leaveType (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    leaveBalance(leaveType: number | undefined, employeeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/LeaveBank/LeaveBalance?";
        if (leaveType === null)
            throw new Error("The parameter 'leaveType' cannot be null.");
        else if (leaveType !== undefined)
            url_ += "leaveType=" + encodeURIComponent("" + leaveType) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeaveBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeaveBalance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLeaveBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    userNotifications(): Observable<UserNotificationResponse> {
        let url_ = this.baseUrl + "/api/Notification/UserNotifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<UserNotificationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNotificationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUserNotifications(response: HttpResponseBase): Observable<UserNotificationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNotificationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UserNotificationResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNotificationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userAllNotifications(body: UserNotificationRequest | undefined): Observable<UserNotificationResponse> {
        let url_ = this.baseUrl + "/api/Notification/UserAllNotifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserAllNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserAllNotifications(<any>response_);
                } catch (e) {
                    return <Observable<UserNotificationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNotificationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUserAllNotifications(response: HttpResponseBase): Observable<UserNotificationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNotificationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UserNotificationResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNotificationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markNotificationViewed(body: MarkNotificationViewedRequest | undefined): Observable<MarkNotificationViewedResponse> {
        let url_ = this.baseUrl + "/api/Notification/MarkNotificationViewed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkNotificationViewed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkNotificationViewed(<any>response_);
                } catch (e) {
                    return <Observable<MarkNotificationViewedResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MarkNotificationViewedResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMarkNotificationViewed(response: HttpResponseBase): Observable<MarkNotificationViewedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarkNotificationViewedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = MarkNotificationViewedResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarkNotificationViewedResponse>(<any>null);
    }
}

@Injectable()
export class ProjectClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProjectRequest | undefined): Observable<CreateProjectResponse> {
        let url_ = this.baseUrl + "/api/Project/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateProjectResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateProjectResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateProjectResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateProjectResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreateProjectResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateProjectResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateProjectRequest | undefined): Observable<UpdateProjectResponse> {
        let url_ = this.baseUrl + "/api/Project/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UpdateProjectResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateProjectResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateProjectResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateProjectResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UpdateProjectResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateProjectResponse>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    singleProject(projectId: number | undefined): Observable<GetSingleProjectResponse> {
        let url_ = this.baseUrl + "/api/Project/SingleProject?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingleProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingleProject(<any>response_);
                } catch (e) {
                    return <Observable<GetSingleProjectResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSingleProjectResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSingleProject(response: HttpResponseBase): Observable<GetSingleProjectResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSingleProjectResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetSingleProjectResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSingleProjectResponse>(<any>null);
    }

    /**
     * @return Success
     */
    projects(): Observable<GetAllProjectsResponse> {
        let url_ = this.baseUrl + "/api/Project/Projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjects(<any>response_);
                } catch (e) {
                    return <Observable<GetAllProjectsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllProjectsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processProjects(response: HttpResponseBase): Observable<GetAllProjectsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllProjectsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetAllProjectsResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllProjectsResponse>(<any>null);
    }
}

@Injectable()
export class ResourceTaskScheduleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getResourceTaskSchedule(body: GetResourceTaskScheduleRequest | undefined): Observable<GetResourceTaskScheduleResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/GetResourceTaskSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResourceTaskSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResourceTaskSchedule(<any>response_);
                } catch (e) {
                    return <Observable<GetResourceTaskScheduleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetResourceTaskScheduleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetResourceTaskSchedule(response: HttpResponseBase): Observable<GetResourceTaskScheduleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetResourceTaskScheduleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetResourceTaskScheduleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetResourceTaskScheduleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleByDates(body: ResourceScheduleByDatesRequest | undefined): Observable<ResourceScheduleByDatesResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/ScheduleByDates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleByDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleByDates(<any>response_);
                } catch (e) {
                    return <Observable<ResourceScheduleByDatesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResourceScheduleByDatesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleByDates(response: HttpResponseBase): Observable<ResourceScheduleByDatesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceScheduleByDatesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResourceScheduleByDatesResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResourceScheduleByDatesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateResourceTaskSchedule(body: UpdateResourceTaskScheduleRequest | undefined): Observable<UpdateResourceTaskScheduleResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/UpdateResourceTaskSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResourceTaskSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResourceTaskSchedule(<any>response_);
                } catch (e) {
                    return <Observable<UpdateResourceTaskScheduleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateResourceTaskScheduleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResourceTaskSchedule(response: HttpResponseBase): Observable<UpdateResourceTaskScheduleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateResourceTaskScheduleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UpdateResourceTaskScheduleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateResourceTaskScheduleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeScheduleApproval(body: RemoveResourceScheduleRequest | undefined): Observable<RemoveResourceScheduleResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/RemoveScheduleApproval";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveScheduleApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveScheduleApproval(<any>response_);
                } catch (e) {
                    return <Observable<RemoveResourceScheduleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RemoveResourceScheduleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveScheduleApproval(response: HttpResponseBase): Observable<RemoveResourceScheduleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoveResourceScheduleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoveResourceScheduleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RemoveResourceScheduleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taskScheduleApprovals(body: GetTaskScheduleApprovalRequest | undefined): Observable<GetTaskScheduleApprovalResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/TaskScheduleApprovals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaskScheduleApprovals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaskScheduleApprovals(<any>response_);
                } catch (e) {
                    return <Observable<GetTaskScheduleApprovalResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaskScheduleApprovalResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTaskScheduleApprovals(response: HttpResponseBase): Observable<GetTaskScheduleApprovalResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskScheduleApprovalResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetTaskScheduleApprovalResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaskScheduleApprovalResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body: ApproveTaskScheduleRequest | undefined): Observable<ApproveTaskScheduleResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<ApproveTaskScheduleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApproveTaskScheduleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<ApproveTaskScheduleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproveTaskScheduleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApproveTaskScheduleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproveTaskScheduleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reject(body: RejectTaskScheduleRequest | undefined): Observable<RejectTaskScheduleResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/Reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(<any>response_);
                } catch (e) {
                    return <Observable<RejectTaskScheduleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RejectTaskScheduleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<RejectTaskScheduleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RejectTaskScheduleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RejectTaskScheduleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RejectTaskScheduleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeWorkload(body: EmployeeWorkloadRequest | undefined): Observable<EmployeeWorkloadResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/EmployeeWorkload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeWorkload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeWorkload(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeWorkloadResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeWorkloadResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeWorkload(response: HttpResponseBase): Observable<EmployeeWorkloadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeWorkloadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = EmployeeWorkloadResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeWorkloadResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    projectTaskSchedule(body: EmployeeProjectTaskScheduleRequest | undefined): Observable<EmployeeProjectTaskScheduelResponse> {
        let url_ = this.baseUrl + "/api/ResourceTaskSchedule/ProjectTaskSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectTaskSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectTaskSchedule(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeProjectTaskScheduelResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeProjectTaskScheduelResponse>><any>_observableThrow(response_);
        }));
    }

    protected processProjectTaskSchedule(response: HttpResponseBase): Observable<EmployeeProjectTaskScheduelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeProjectTaskScheduelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = EmployeeProjectTaskScheduelResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeProjectTaskScheduelResponse>(<any>null);
    }
}

@Injectable()
export class RoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    roles(body: GetRolesRequest | undefined): Observable<GetRoleListResponse> {
        let url_ = this.baseUrl + "/api/Role/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<GetRoleListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetRoleListResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleListResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesWithPermissions(body: GetRoleWithPermissionRequest | undefined): Observable<GetRoleWithPermissionsResponse> {
        let url_ = this.baseUrl + "/api/Role/RolesWithPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesWithPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesWithPermissions(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleWithPermissionsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleWithPermissionsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRolesWithPermissions(response: HttpResponseBase): Observable<GetRoleWithPermissionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleWithPermissionsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetRoleWithPermissionsResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleWithPermissionsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleRequest | undefined): Observable<CreateRoleResponse> {
        let url_ = this.baseUrl + "/api/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateRoleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRoleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateRoleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRoleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreateRoleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRoleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRoleRequest | undefined): Observable<UpdateRoleResponse> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UpdateRoleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateRoleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateRoleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateRoleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UpdateRoleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateRoleResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRolePermissions(body: UpdateRolePermissionsRequest | undefined): Observable<UpdateRolePermissionsResponse> {
        let url_ = this.baseUrl + "/api/Role/UpdateRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<UpdateRolePermissionsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateRolePermissionsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRolePermissions(response: HttpResponseBase): Observable<UpdateRolePermissionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateRolePermissionsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UpdateRolePermissionsResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateRolePermissionsResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: DeleteRoleRequest | undefined): Observable<DeleteRoleResponse> {
        let url_ = this.baseUrl + "/api/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<DeleteRoleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeleteRoleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DeleteRoleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteRoleResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = DeleteRoleResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteRoleResponse>(<any>null);
    }
}

@Injectable()
export class TaskClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTaskRequest | undefined): Observable<CreateTaskResponse> {
        let url_ = this.baseUrl + "/api/Task/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateTaskResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateTaskResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateTaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTaskResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreateTaskResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTaskResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    multiProjectTaskAndResourceAssignment(body: MultiprojectTaskAssignmentRequest | undefined): Observable<MultiprojectTaskAssignmentResponse> {
        let url_ = this.baseUrl + "/api/Task/MultiProjectTaskAndResourceAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMultiProjectTaskAndResourceAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMultiProjectTaskAndResourceAssignment(<any>response_);
                } catch (e) {
                    return <Observable<MultiprojectTaskAssignmentResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MultiprojectTaskAssignmentResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMultiProjectTaskAndResourceAssignment(response: HttpResponseBase): Observable<MultiprojectTaskAssignmentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MultiprojectTaskAssignmentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = MultiprojectTaskAssignmentResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MultiprojectTaskAssignmentResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTaskRequest | undefined): Observable<UpdateTaskResponse> {
        let url_ = this.baseUrl + "/api/Task/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UpdateTaskResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateTaskResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateTaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateTaskResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = UpdateTaskResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateTaskResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: DeleteTaskRequest | undefined): Observable<DeleteTaskResponse> {
        let url_ = this.baseUrl + "/api/Task/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<DeleteTaskResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeleteTaskResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DeleteTaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteTaskResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = DeleteTaskResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteTaskResponse>(<any>null);
    }
}

@Injectable()
export class TaskLinkClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTaskLink(body: AddTaskLinkRequest | undefined): Observable<AddTaskLinkResponse> {
        let url_ = this.baseUrl + "/api/TaskLink/AddTaskLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTaskLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTaskLink(<any>response_);
                } catch (e) {
                    return <Observable<AddTaskLinkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTaskLinkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddTaskLink(response: HttpResponseBase): Observable<AddTaskLinkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTaskLinkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AddTaskLinkResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTaskLinkResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeTaskLink(body: RemoveTaskLinkRequest | undefined): Observable<AddTaskLinkResponse> {
        let url_ = this.baseUrl + "/api/TaskLink/RemoveTaskLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTaskLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTaskLink(<any>response_);
                } catch (e) {
                    return <Observable<AddTaskLinkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTaskLinkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTaskLink(response: HttpResponseBase): Observable<AddTaskLinkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTaskLinkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AddTaskLinkResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTaskLinkResponse>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getTaskLinks(projectId: number | undefined): Observable<GetTaskLinksRespone> {
        let url_ = this.baseUrl + "/api/TaskLink/GetTaskLinks?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskLinks(<any>response_);
                } catch (e) {
                    return <Observable<GetTaskLinksRespone>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaskLinksRespone>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaskLinks(response: HttpResponseBase): Observable<GetTaskLinksRespone> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskLinksRespone.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetTaskLinksRespone.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaskLinksRespone>(<any>null);
    }
}

@Injectable()
export class TaskResourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignResource(body: AddTaskResourceRequest | undefined): Observable<AddTaskResourceResponse> {
        let url_ = this.baseUrl + "/api/TaskResource/AssignResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignResource(<any>response_);
                } catch (e) {
                    return <Observable<AddTaskResourceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTaskResourceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAssignResource(response: HttpResponseBase): Observable<AddTaskResourceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTaskResourceResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AddTaskResourceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTaskResourceResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeResource(body: DeleteTaskRsourceRequest | undefined): Observable<DeleteTaskResourceResponse> {
        let url_ = this.baseUrl + "/api/TaskResource/RemoveResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveResource(<any>response_);
                } catch (e) {
                    return <Observable<DeleteTaskResourceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeleteTaskResourceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveResource(response: HttpResponseBase): Observable<DeleteTaskResourceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteTaskResourceResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = DeleteTaskResourceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteTaskResourceResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserTasks(body: GetUserTasksRequest | undefined): Observable<GetUserTasksResponse> {
        let url_ = this.baseUrl + "/api/TaskResource/GetUserTasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTasks(<any>response_);
                } catch (e) {
                    return <Observable<GetUserTasksResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserTasksResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTasks(response: HttpResponseBase): Observable<GetUserTasksResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserTasksResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetUserTasksResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserTasksResponse>(<any>null);
    }
}

@Injectable()
export class TaskTimeSheetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taskCheckIn(body: TaskCheckInRequest | undefined): Observable<TaskCheckInResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/TaskCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaskCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaskCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<TaskCheckInResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaskCheckInResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTaskCheckIn(response: HttpResponseBase): Observable<TaskCheckInResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskCheckInResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = TaskCheckInResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaskCheckInResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taskCheckOut(body: TaskCheckOutRequest | undefined): Observable<TaskCheckOutResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/TaskCheckOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaskCheckOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaskCheckOut(<any>response_);
                } catch (e) {
                    return <Observable<TaskCheckOutResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaskCheckOutResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTaskCheckOut(response: HttpResponseBase): Observable<TaskCheckOutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskCheckOutResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = TaskCheckOutResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaskCheckOutResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taskTimeSheetPost(body: GetTaskTimeSheetForUserRequest | undefined): Observable<GetTaskTimeSheetForUserResonse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/TaskTimeSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaskTimeSheetPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaskTimeSheetPost(<any>response_);
                } catch (e) {
                    return <Observable<GetTaskTimeSheetForUserResonse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaskTimeSheetForUserResonse>><any>_observableThrow(response_);
        }));
    }

    protected processTaskTimeSheetPost(response: HttpResponseBase): Observable<GetTaskTimeSheetForUserResonse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskTimeSheetForUserResonse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetTaskTimeSheetForUserResonse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaskTimeSheetForUserResonse>(<any>null);
    }

    /**
     * @param resourceTaskScheduleId (optional) 
     * @return Success
     */
    taskTimeSheetGet(resourceTaskScheduleId: number | undefined): Observable<GetInProgressTimeSheetResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/TaskTimeSheet?";
        if (resourceTaskScheduleId === null)
            throw new Error("The parameter 'resourceTaskScheduleId' cannot be null.");
        else if (resourceTaskScheduleId !== undefined)
            url_ += "resourceTaskScheduleId=" + encodeURIComponent("" + resourceTaskScheduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaskTimeSheetGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaskTimeSheetGet(<any>response_);
                } catch (e) {
                    return <Observable<GetInProgressTimeSheetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInProgressTimeSheetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTaskTimeSheetGet(response: HttpResponseBase): Observable<GetInProgressTimeSheetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInProgressTimeSheetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetInProgressTimeSheetResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInProgressTimeSheetResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeAttendance(body: GetEmployeeAttendanceRequest | undefined): Observable<GetEmployeeAttendanceResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/EmployeeAttendance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeAttendance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeAttendance(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeAttendanceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeAttendanceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeAttendance(response: HttpResponseBase): Observable<GetEmployeeAttendanceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeAttendanceResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetEmployeeAttendanceResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeAttendanceResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeWorkedHours(body: EmployeeWorkHoursRequest | undefined): Observable<EmployeeWorkHoursResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/EmployeeWorkedHours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeWorkedHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeWorkedHours(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeWorkHoursResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeWorkHoursResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeWorkedHours(response: HttpResponseBase): Observable<EmployeeWorkHoursResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeWorkHoursResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = EmployeeWorkHoursResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeWorkHoursResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeeCheckInOutDetails(body: GetEmployeeCheckInOutDetailsRequest | undefined): Observable<GetEmployeeCheckInOutDetailsResponse> {
        let url_ = this.baseUrl + "/api/TaskTimeSheet/EmployeeCheckInOutDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeCheckInOutDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeCheckInOutDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeCheckInOutDetailsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeCheckInOutDetailsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeCheckInOutDetails(response: HttpResponseBase): Observable<GetEmployeeCheckInOutDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeCheckInOutDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = GetEmployeeCheckInOutDetailsResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeCheckInOutDetailsResponse>(<any>null);
    }
}

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherForecast(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class AddTaskLinkRequest implements IAddTaskLinkRequest {
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;

    constructor(data?: IAddTaskLinkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceTaskId = _data["sourceTaskId"];
            this.targetTaskId = _data["targetTaskId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): AddTaskLinkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddTaskLinkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceTaskId"] = this.sourceTaskId;
        data["targetTaskId"] = this.targetTaskId;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface IAddTaskLinkRequest {
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
}

export class AddTaskLinkResponse implements IAddTaskLinkResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IAddTaskLinkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): AddTaskLinkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddTaskLinkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IAddTaskLinkResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class AddTaskResourceRequest implements IAddTaskResourceRequest {
    allocatedHours?: number;
    taskId?: number;
    employeeId?: number;
    startDate?: Date;
    endDate?: Date;
    isDefault?: boolean;
    isSingle?: boolean;
    isMultiple?: boolean;
    isRecurring?: boolean;
    recurringDays?: number[] | undefined;
    recurringAssignmentType?: ResourceAssignmentType;

    constructor(data?: IAddTaskResourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allocatedHours = _data["allocatedHours"];
            this.taskId = _data["taskId"];
            this.employeeId = _data["employeeId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isDefault = _data["isDefault"];
            this.isSingle = _data["isSingle"];
            this.isMultiple = _data["isMultiple"];
            this.isRecurring = _data["isRecurring"];
            if (Array.isArray(_data["recurringDays"])) {
                this.recurringDays = [] as any;
                for (let item of _data["recurringDays"])
                    this.recurringDays!.push(item);
            }
            this.recurringAssignmentType = _data["recurringAssignmentType"];
        }
    }

    static fromJS(data: any): AddTaskResourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddTaskResourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allocatedHours"] = this.allocatedHours;
        data["taskId"] = this.taskId;
        data["employeeId"] = this.employeeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["isSingle"] = this.isSingle;
        data["isMultiple"] = this.isMultiple;
        data["isRecurring"] = this.isRecurring;
        if (Array.isArray(this.recurringDays)) {
            data["recurringDays"] = [];
            for (let item of this.recurringDays)
                data["recurringDays"].push(item);
        }
        data["recurringAssignmentType"] = this.recurringAssignmentType;
        return data; 
    }
}

export interface IAddTaskResourceRequest {
    allocatedHours?: number;
    taskId?: number;
    employeeId?: number;
    startDate?: Date;
    endDate?: Date;
    isDefault?: boolean;
    isSingle?: boolean;
    isMultiple?: boolean;
    isRecurring?: boolean;
    recurringDays?: number[] | undefined;
    recurringAssignmentType?: ResourceAssignmentType;
}

export class AddTaskResourceResponse implements IAddTaskResourceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    taskResource?: TaskResource;
    resourceTaskSchedules?: ResourceTaskSchedule[] | undefined;

    constructor(data?: IAddTaskResourceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.taskResource = _data["taskResource"] ? TaskResource.fromJS(_data["taskResource"]) : <any>undefined;
            if (Array.isArray(_data["resourceTaskSchedules"])) {
                this.resourceTaskSchedules = [] as any;
                for (let item of _data["resourceTaskSchedules"])
                    this.resourceTaskSchedules!.push(ResourceTaskSchedule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddTaskResourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddTaskResourceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["taskResource"] = this.taskResource ? this.taskResource.toJSON() : <any>undefined;
        if (Array.isArray(this.resourceTaskSchedules)) {
            data["resourceTaskSchedules"] = [];
            for (let item of this.resourceTaskSchedules)
                data["resourceTaskSchedules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddTaskResourceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    taskResource?: TaskResource;
    resourceTaskSchedules?: ResourceTaskSchedule[] | undefined;
}

export class ApplyLeaveRequest implements IApplyLeaveRequest {
    startDate?: Date;
    endDate?: Date;
    leaveType?: LeaveType;
    reason?: string | undefined;

    constructor(data?: IApplyLeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.leaveType = _data["leaveType"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ApplyLeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyLeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveType"] = this.leaveType;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IApplyLeaveRequest {
    startDate?: Date;
    endDate?: Date;
    leaveType?: LeaveType;
    reason?: string | undefined;
}

export class ApplyLeaveResponse implements IApplyLeaveResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IApplyLeaveResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplyLeaveResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyLeaveResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IApplyLeaveResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class ApplyTimeOffRequest implements IApplyTimeOffRequest {
    start?: string | undefined;
    end?: string | undefined;
    date?: Date;
    reason?: string | undefined;

    constructor(data?: IApplyTimeOffRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.end = _data["end"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ApplyTimeOffRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyTimeOffRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["end"] = this.end;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IApplyTimeOffRequest {
    start?: string | undefined;
    end?: string | undefined;
    date?: Date;
    reason?: string | undefined;
}

export class ApplyTimeOffResponse implements IApplyTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IApplyTimeOffResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplyTimeOffResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyTimeOffResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IApplyTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class ApproveLeaveRequest implements IApproveLeaveRequest {
    id?: number;

    constructor(data?: IApproveLeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApproveLeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveLeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IApproveLeaveRequest {
    id?: number;
}

export class ApproveLeaveResponse implements IApproveLeaveResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IApproveLeaveResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApproveLeaveResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveLeaveResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IApproveLeaveResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class ApproveTaskScheduleRequest implements IApproveTaskScheduleRequest {
    taskScheduleIds?: number[] | undefined;

    constructor(data?: IApproveTaskScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["taskScheduleIds"])) {
                this.taskScheduleIds = [] as any;
                for (let item of _data["taskScheduleIds"])
                    this.taskScheduleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ApproveTaskScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTaskScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.taskScheduleIds)) {
            data["taskScheduleIds"] = [];
            for (let item of this.taskScheduleIds)
                data["taskScheduleIds"].push(item);
        }
        return data; 
    }
}

export interface IApproveTaskScheduleRequest {
    taskScheduleIds?: number[] | undefined;
}

export class ApproveTaskScheduleResponse implements IApproveTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IApproveTaskScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApproveTaskScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTaskScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IApproveTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class ApproveTimeOffRequest implements IApproveTimeOffRequest {
    id?: number;
    comments?: string | undefined;

    constructor(data?: IApproveTimeOffRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ApproveTimeOffRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTimeOffRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IApproveTimeOffRequest {
    id?: number;
    comments?: string | undefined;
}

export class ApproveTimeOffResponse implements IApproveTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IApproveTimeOffResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApproveTimeOffResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveTimeOffResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IApproveTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confrimNewPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confrimNewPassword = _data["confrimNewPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confrimNewPassword"] = this.confrimNewPassword;
        return data; 
    }
}

export interface IChangePasswordRequest {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confrimNewPassword?: string | undefined;
}

export class ChangePasswordResponse implements IChangePasswordResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IChangePasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): ChangePasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IChangePasswordResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class CreateProjectRequest implements ICreateProjectRequest {
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    location?: string | undefined;

    constructor(data?: ICreateProjectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreateProjectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        return data; 
    }
}

export interface ICreateProjectRequest {
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    location?: string | undefined;
}

export class CreateProjectResponse implements ICreateProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: SimpleProjectDto;

    constructor(data?: ICreateProjectResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.project = _data["project"] ? SimpleProjectDto.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: SimpleProjectDto;
}

export class CreateRoleRequest implements ICreateRoleRequest {
    name?: string | undefined;
    permissions?: number[] | undefined;

    constructor(data?: ICreateRoleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface ICreateRoleRequest {
    name?: string | undefined;
    permissions?: number[] | undefined;
}

export class CreateRoleResponse implements ICreateRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: ICreateRoleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface ICreateRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class CreateTaskRequest implements ICreateTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    projectId?: number;

    constructor(data?: ICreateTaskRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.verb = _data["verb"];
            this.parentTaskId = _data["parentTaskId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): CreateTaskRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["verb"] = this.verb;
        data["parentTaskId"] = this.parentTaskId;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface ICreateTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    projectId?: number;
}

export class CreateTaskResponse implements ICreateTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    task?: TaskDto;

    constructor(data?: ICreateTaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.task = _data["task"] ? TaskDto.fromJS(_data["task"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["task"] = this.task ? this.task.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    task?: TaskDto;
}

export class DeleteRoleRequest implements IDeleteRoleRequest {
    id?: number;

    constructor(data?: IDeleteRoleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteRoleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeleteRoleRequest {
    id?: number;
}

export class DeleteRoleResponse implements IDeleteRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IDeleteRoleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteRoleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IDeleteRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class DeleteTaskRequest implements IDeleteTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    id?: number;
    projectId?: number;

    constructor(data?: IDeleteTaskRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.verb = _data["verb"];
            this.parentTaskId = _data["parentTaskId"];
            this.id = _data["id"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): DeleteTaskRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["verb"] = this.verb;
        data["parentTaskId"] = this.parentTaskId;
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface IDeleteTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    id?: number;
    projectId?: number;
}

export class DeleteTaskResourceResponse implements IDeleteTaskResourceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IDeleteTaskResourceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteTaskResourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskResourceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IDeleteTaskResourceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class DeleteTaskResponse implements IDeleteTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IDeleteTaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteTaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IDeleteTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class DeleteTaskRsourceRequest implements IDeleteTaskRsourceRequest {
    allocatedHours?: number;
    taskId?: number;
    employeeId?: number;

    constructor(data?: IDeleteTaskRsourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allocatedHours = _data["allocatedHours"];
            this.taskId = _data["taskId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): DeleteTaskRsourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTaskRsourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allocatedHours"] = this.allocatedHours;
        data["taskId"] = this.taskId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IDeleteTaskRsourceRequest {
    allocatedHours?: number;
    taskId?: number;
    employeeId?: number;
}

export class Department implements IDepartment {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    departmentType?: string | undefined;
    dateCreated?: Date;
    designations?: Designation[] | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.departmentType = _data["departmentType"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            if (Array.isArray(_data["designations"])) {
                this.designations = [] as any;
                for (let item of _data["designations"])
                    this.designations!.push(Designation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["departmentType"] = this.departmentType;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        if (Array.isArray(this.designations)) {
            data["designations"] = [];
            for (let item of this.designations)
                data["designations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDepartment {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    departmentType?: string | undefined;
    dateCreated?: Date;
    designations?: Designation[] | undefined;
}

export class DepartmentDto implements IDepartmentDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDepartmentDto {
    id?: number;
    name?: string | undefined;
}

export class Designation implements IDesignation {
    id?: number;
    name?: string | undefined;
    departmentId?: number;
    department?: Department;
    employees?: Employee[] | undefined;

    constructor(data?: IDesignation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(Employee.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Designation {
        data = typeof data === 'object' ? data : {};
        let result = new Designation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDesignation {
    id?: number;
    name?: string | undefined;
    departmentId?: number;
    department?: Department;
    employees?: Employee[] | undefined;
}

export class DesignationDto implements IDesignationDto {
    id?: number;
    name?: string | undefined;
    departmentId?: number;
    employees?: EmployeeForDesignationDto[] | undefined;

    constructor(data?: IDesignationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.departmentId = _data["departmentId"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeForDesignationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DesignationDto {
        data = typeof data === 'object' ? data : {};
        let result = new DesignationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["departmentId"] = this.departmentId;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDesignationDto {
    id?: number;
    name?: string | undefined;
    departmentId?: number;
    employees?: EmployeeForDesignationDto[] | undefined;
}

export class DesignationsWithEmployeesResponse implements IDesignationsWithEmployeesResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    designations?: DesignationDto[] | undefined;

    constructor(data?: IDesignationsWithEmployeesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["designations"])) {
                this.designations = [] as any;
                for (let item of _data["designations"])
                    this.designations!.push(DesignationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DesignationsWithEmployeesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DesignationsWithEmployeesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.designations)) {
            data["designations"] = [];
            for (let item of this.designations)
                data["designations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDesignationsWithEmployeesResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    designations?: DesignationDto[] | undefined;
}

export class Employee implements IEmployee {
    id?: number;
    employeeCode?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    userId?: number;
    isActive?: boolean;
    user?: User;
    designationId?: number;
    designation?: Designation;
    assignedTasks?: TaskResource[] | undefined;
    createdProjects?: Project[] | undefined;
    createdTasks?: Task[] | undefined;
    applliedTimeOffs?: TimeOff[] | undefined;
    leaves?: Leave[] | undefined;
    leaveBank?: LeaveBank[] | undefined;
    subordinates?: EmployeeHeirarchy[] | undefined;
    leads?: EmployeeHeirarchy[] | undefined;
    notifications?: Notification[] | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCode = _data["employeeCode"];
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.designationId = _data["designationId"];
            this.designation = _data["designation"] ? Designation.fromJS(_data["designation"]) : <any>undefined;
            if (Array.isArray(_data["assignedTasks"])) {
                this.assignedTasks = [] as any;
                for (let item of _data["assignedTasks"])
                    this.assignedTasks!.push(TaskResource.fromJS(item));
            }
            if (Array.isArray(_data["createdProjects"])) {
                this.createdProjects = [] as any;
                for (let item of _data["createdProjects"])
                    this.createdProjects!.push(Project.fromJS(item));
            }
            if (Array.isArray(_data["createdTasks"])) {
                this.createdTasks = [] as any;
                for (let item of _data["createdTasks"])
                    this.createdTasks!.push(Task.fromJS(item));
            }
            if (Array.isArray(_data["applliedTimeOffs"])) {
                this.applliedTimeOffs = [] as any;
                for (let item of _data["applliedTimeOffs"])
                    this.applliedTimeOffs!.push(TimeOff.fromJS(item));
            }
            if (Array.isArray(_data["leaves"])) {
                this.leaves = [] as any;
                for (let item of _data["leaves"])
                    this.leaves!.push(Leave.fromJS(item));
            }
            if (Array.isArray(_data["leaveBank"])) {
                this.leaveBank = [] as any;
                for (let item of _data["leaveBank"])
                    this.leaveBank!.push(LeaveBank.fromJS(item));
            }
            if (Array.isArray(_data["subordinates"])) {
                this.subordinates = [] as any;
                for (let item of _data["subordinates"])
                    this.subordinates!.push(EmployeeHeirarchy.fromJS(item));
            }
            if (Array.isArray(_data["leads"])) {
                this.leads = [] as any;
                for (let item of _data["leads"])
                    this.leads!.push(EmployeeHeirarchy.fromJS(item));
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCode"] = this.employeeCode;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["designationId"] = this.designationId;
        data["designation"] = this.designation ? this.designation.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedTasks)) {
            data["assignedTasks"] = [];
            for (let item of this.assignedTasks)
                data["assignedTasks"].push(item.toJSON());
        }
        if (Array.isArray(this.createdProjects)) {
            data["createdProjects"] = [];
            for (let item of this.createdProjects)
                data["createdProjects"].push(item.toJSON());
        }
        if (Array.isArray(this.createdTasks)) {
            data["createdTasks"] = [];
            for (let item of this.createdTasks)
                data["createdTasks"].push(item.toJSON());
        }
        if (Array.isArray(this.applliedTimeOffs)) {
            data["applliedTimeOffs"] = [];
            for (let item of this.applliedTimeOffs)
                data["applliedTimeOffs"].push(item.toJSON());
        }
        if (Array.isArray(this.leaves)) {
            data["leaves"] = [];
            for (let item of this.leaves)
                data["leaves"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveBank)) {
            data["leaveBank"] = [];
            for (let item of this.leaveBank)
                data["leaveBank"].push(item.toJSON());
        }
        if (Array.isArray(this.subordinates)) {
            data["subordinates"] = [];
            for (let item of this.subordinates)
                data["subordinates"].push(item.toJSON());
        }
        if (Array.isArray(this.leads)) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployee {
    id?: number;
    employeeCode?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    userId?: number;
    isActive?: boolean;
    user?: User;
    designationId?: number;
    designation?: Designation;
    assignedTasks?: TaskResource[] | undefined;
    createdProjects?: Project[] | undefined;
    createdTasks?: Task[] | undefined;
    applliedTimeOffs?: TimeOff[] | undefined;
    leaves?: Leave[] | undefined;
    leaveBank?: LeaveBank[] | undefined;
    subordinates?: EmployeeHeirarchy[] | undefined;
    leads?: EmployeeHeirarchy[] | undefined;
    notifications?: Notification[] | undefined;
}

export class EmployeeAttendanceDto implements IEmployeeAttendanceDto {
    id?: number;
    name?: string | undefined;
    checkIn?: any | undefined;
    checkOut?: any | undefined;
    workedHours?: number;
    date?: string | undefined;

    constructor(data?: IEmployeeAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.workedHours = _data["workedHours"];
            this.date = _data["date"];
        }
    }

    static fromJS(data: any): EmployeeAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["workedHours"] = this.workedHours;
        data["date"] = this.date;
        return data; 
    }
}

export interface IEmployeeAttendanceDto {
    id?: number;
    name?: string | undefined;
    checkIn?: any | undefined;
    checkOut?: any | undefined;
    workedHours?: number;
    date?: string | undefined;
}

export class EmployeeCheckInOutDetailsDto implements IEmployeeCheckInOutDetailsDto {
    id?: number;
    name?: string | undefined;
    projectName?: string | undefined;
    checkIn?: any | undefined;
    checkOut?: any | undefined;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    minutes?: number;
    date?: string | undefined;
    checkInLocDiff?: string | undefined;
    checkOutLocDiff?: string | undefined;
    checkInNotes?: string | undefined;
    checkOutNotes?: string | undefined;

    constructor(data?: IEmployeeCheckInOutDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.projectName = _data["projectName"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.checkInLocation = _data["checkInLocation"];
            this.checkOutLocation = _data["checkOutLocation"];
            this.minutes = _data["minutes"];
            this.date = _data["date"];
            this.checkInLocDiff = _data["checkInLocDiff"];
            this.checkOutLocDiff = _data["checkOutLocDiff"];
            this.checkInNotes = _data["checkInNotes"];
            this.checkOutNotes = _data["checkOutNotes"];
        }
    }

    static fromJS(data: any): EmployeeCheckInOutDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCheckInOutDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["projectName"] = this.projectName;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["checkInLocation"] = this.checkInLocation;
        data["checkOutLocation"] = this.checkOutLocation;
        data["minutes"] = this.minutes;
        data["date"] = this.date;
        data["checkInLocDiff"] = this.checkInLocDiff;
        data["checkOutLocDiff"] = this.checkOutLocDiff;
        data["checkInNotes"] = this.checkInNotes;
        data["checkOutNotes"] = this.checkOutNotes;
        return data; 
    }
}

export interface IEmployeeCheckInOutDetailsDto {
    id?: number;
    name?: string | undefined;
    projectName?: string | undefined;
    checkIn?: any | undefined;
    checkOut?: any | undefined;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    minutes?: number;
    date?: string | undefined;
    checkInLocDiff?: string | undefined;
    checkOutLocDiff?: string | undefined;
    checkInNotes?: string | undefined;
    checkOutNotes?: string | undefined;
}

export class EmployeeForAttendanceDto implements IEmployeeForAttendanceDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IEmployeeForAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeForAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeForAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IEmployeeForAttendanceDto {
    id?: number;
    name?: string | undefined;
}

export class EmployeeForDesignationDto implements IEmployeeForDesignationDto {
    id?: number;
    name?: string | undefined;
    designationId?: number;

    constructor(data?: IEmployeeForDesignationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.designationId = _data["designationId"];
        }
    }

    static fromJS(data: any): EmployeeForDesignationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeForDesignationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["designationId"] = this.designationId;
        return data; 
    }
}

export interface IEmployeeForDesignationDto {
    id?: number;
    name?: string | undefined;
    designationId?: number;
}

export class EmployeeHeirarchy implements IEmployeeHeirarchy {
    subordinateId?: number;
    leadId?: number;
    subordinate?: Employee;
    lead?: Employee;

    constructor(data?: IEmployeeHeirarchy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subordinateId = _data["subordinateId"];
            this.leadId = _data["leadId"];
            this.subordinate = _data["subordinate"] ? Employee.fromJS(_data["subordinate"]) : <any>undefined;
            this.lead = _data["lead"] ? Employee.fromJS(_data["lead"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeHeirarchy {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeHeirarchy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subordinateId"] = this.subordinateId;
        data["leadId"] = this.leadId;
        data["subordinate"] = this.subordinate ? this.subordinate.toJSON() : <any>undefined;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEmployeeHeirarchy {
    subordinateId?: number;
    leadId?: number;
    subordinate?: Employee;
    lead?: Employee;
}

export class EmployeeLeavesDto implements IEmployeeLeavesDto {
    id?: number;
    employeeId?: number;
    empName?: string | undefined;
    leaveType?: string | undefined;
    currentStatus?: number;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IEmployeeLeavesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.empName = _data["empName"];
            this.leaveType = _data["leaveType"];
            this.currentStatus = _data["currentStatus"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeLeavesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeLeavesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["empName"] = this.empName;
        data["leaveType"] = this.leaveType;
        data["currentStatus"] = this.currentStatus;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEmployeeLeavesDto {
    id?: number;
    employeeId?: number;
    empName?: string | undefined;
    leaveType?: string | undefined;
    currentStatus?: number;
    startDate?: Date;
    endDate?: Date;
}

export class EmployeeProjectTaskScheduelResponse implements IEmployeeProjectTaskScheduelResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeSchedule?: EmployeeProjectTaskScheduleDto[] | undefined;

    constructor(data?: IEmployeeProjectTaskScheduelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employeeSchedule"])) {
                this.employeeSchedule = [] as any;
                for (let item of _data["employeeSchedule"])
                    this.employeeSchedule!.push(EmployeeProjectTaskScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeProjectTaskScheduelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeProjectTaskScheduelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employeeSchedule)) {
            data["employeeSchedule"] = [];
            for (let item of this.employeeSchedule)
                data["employeeSchedule"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployeeProjectTaskScheduelResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeSchedule?: EmployeeProjectTaskScheduleDto[] | undefined;
}

export class EmployeeProjectTaskScheduleDto implements IEmployeeProjectTaskScheduleDto {
    employeeName?: string | undefined;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    allocatedHours?: number;

    constructor(data?: IEmployeeProjectTaskScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeName = _data["employeeName"];
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.allocatedHours = _data["allocatedHours"];
        }
    }

    static fromJS(data: any): EmployeeProjectTaskScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeProjectTaskScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeName"] = this.employeeName;
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allocatedHours"] = this.allocatedHours;
        return data; 
    }
}

export interface IEmployeeProjectTaskScheduleDto {
    employeeName?: string | undefined;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    allocatedHours?: number;
}

export class EmployeeProjectTaskScheduleRequest implements IEmployeeProjectTaskScheduleRequest {
    employeeId?: number;
    projectId?: number;
    start?: string | undefined;
    end?: string | undefined;

    constructor(data?: IEmployeeProjectTaskScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.projectId = _data["projectId"];
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): EmployeeProjectTaskScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeProjectTaskScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["projectId"] = this.projectId;
        data["start"] = this.start;
        data["end"] = this.end;
        return data; 
    }
}

export interface IEmployeeProjectTaskScheduleRequest {
    employeeId?: number;
    projectId?: number;
    start?: string | undefined;
    end?: string | undefined;
}

export class EmployeeTimeOffDto implements IEmployeeTimeOffDto {
    id?: number;
    empName?: string | undefined;
    start?: Date;
    end?: Date;
    statusId?: number;
    status?: string | undefined;
    reason?: string | undefined;
    appliedDate?: Date;

    constructor(data?: IEmployeeTimeOffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empName = _data["empName"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"];
            this.reason = _data["reason"];
            this.appliedDate = _data["appliedDate"] ? new Date(_data["appliedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeTimeOffDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTimeOffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empName"] = this.empName;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status;
        data["reason"] = this.reason;
        data["appliedDate"] = this.appliedDate ? this.appliedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEmployeeTimeOffDto {
    id?: number;
    empName?: string | undefined;
    start?: Date;
    end?: Date;
    statusId?: number;
    status?: string | undefined;
    reason?: string | undefined;
    appliedDate?: Date;
}

export class EmployeeWorkHoursDto implements IEmployeeWorkHoursDto {
    id?: number;
    name?: string | undefined;
    workedHours?: number;
    allocatedHours?: number;

    constructor(data?: IEmployeeWorkHoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.workedHours = _data["workedHours"];
            this.allocatedHours = _data["allocatedHours"];
        }
    }

    static fromJS(data: any): EmployeeWorkHoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkHoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["workedHours"] = this.workedHours;
        data["allocatedHours"] = this.allocatedHours;
        return data; 
    }
}

export interface IEmployeeWorkHoursDto {
    id?: number;
    name?: string | undefined;
    workedHours?: number;
    allocatedHours?: number;
}

export class EmployeeWorkHoursRequest implements IEmployeeWorkHoursRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;

    constructor(data?: IEmployeeWorkHoursRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EmployeeWorkHoursRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkHoursRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data; 
    }
}

export interface IEmployeeWorkHoursRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;
}

export class EmployeeWorkHoursResponse implements IEmployeeWorkHoursResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    emplyeeWorkHours?: EmployeeWorkHoursDto[] | undefined;
    totalCount?: number;

    constructor(data?: IEmployeeWorkHoursResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["emplyeeWorkHours"])) {
                this.emplyeeWorkHours = [] as any;
                for (let item of _data["emplyeeWorkHours"])
                    this.emplyeeWorkHours!.push(EmployeeWorkHoursDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeWorkHoursResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkHoursResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.emplyeeWorkHours)) {
            data["emplyeeWorkHours"] = [];
            for (let item of this.emplyeeWorkHours)
                data["emplyeeWorkHours"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IEmployeeWorkHoursResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    emplyeeWorkHours?: EmployeeWorkHoursDto[] | undefined;
    totalCount?: number;
}

export class EmployeeWorkLoadDto implements IEmployeeWorkLoadDto {
    employeeId?: number;
    name?: string | undefined;
    workLoad?: ProjectWorkLoadDto[] | undefined;

    constructor(data?: IEmployeeWorkLoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            if (Array.isArray(_data["workLoad"])) {
                this.workLoad = [] as any;
                for (let item of _data["workLoad"])
                    this.workLoad!.push(ProjectWorkLoadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeWorkLoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkLoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        if (Array.isArray(this.workLoad)) {
            data["workLoad"] = [];
            for (let item of this.workLoad)
                data["workLoad"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployeeWorkLoadDto {
    employeeId?: number;
    name?: string | undefined;
    workLoad?: ProjectWorkLoadDto[] | undefined;
}

export class EmployeeWorkloadRequest implements IEmployeeWorkloadRequest {
    employeeIds?: number[] | undefined;
    projectIds?: number[] | undefined;

    constructor(data?: IEmployeeWorkloadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EmployeeWorkloadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkloadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data; 
    }
}

export interface IEmployeeWorkloadRequest {
    employeeIds?: number[] | undefined;
    projectIds?: number[] | undefined;
}

export class EmployeeWorkloadResponse implements IEmployeeWorkloadResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeWorkload?: EmployeeWorkLoadDto[] | undefined;

    constructor(data?: IEmployeeWorkloadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employeeWorkload"])) {
                this.employeeWorkload = [] as any;
                for (let item of _data["employeeWorkload"])
                    this.employeeWorkload!.push(EmployeeWorkLoadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeWorkloadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeWorkloadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employeeWorkload)) {
            data["employeeWorkload"] = [];
            for (let item of this.employeeWorkload)
                data["employeeWorkload"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployeeWorkloadResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeWorkload?: EmployeeWorkLoadDto[] | undefined;
}

export class GetAllProjectsResponse implements IGetAllProjectsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    projects?: SimpleProjectDto[] | undefined;

    constructor(data?: IGetAllProjectsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(SimpleProjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllProjectsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllProjectsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAllProjectsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    projects?: SimpleProjectDto[] | undefined;
}

export class GetDepartmentsResponse implements IGetDepartmentsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    departments?: DepartmentDto[] | undefined;

    constructor(data?: IGetDepartmentsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments!.push(DepartmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDepartmentsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDepartmentsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDepartmentsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    departments?: DepartmentDto[] | undefined;
}

export class GetEmployeeAttendanceRequest implements IGetEmployeeAttendanceRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;

    constructor(data?: IGetEmployeeAttendanceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeeAttendanceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeAttendanceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data; 
    }
}

export interface IGetEmployeeAttendanceRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;
}

export class GetEmployeeAttendanceResponse implements IGetEmployeeAttendanceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    emplyeeAttendance?: EmployeeAttendanceDto[] | undefined;
    totalCount?: number;

    constructor(data?: IGetEmployeeAttendanceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["emplyeeAttendance"])) {
                this.emplyeeAttendance = [] as any;
                for (let item of _data["emplyeeAttendance"])
                    this.emplyeeAttendance!.push(EmployeeAttendanceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetEmployeeAttendanceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeAttendanceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.emplyeeAttendance)) {
            data["emplyeeAttendance"] = [];
            for (let item of this.emplyeeAttendance)
                data["emplyeeAttendance"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IGetEmployeeAttendanceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    emplyeeAttendance?: EmployeeAttendanceDto[] | undefined;
    totalCount?: number;
}

export class GetEmployeeCheckInOutDetailsRequest implements IGetEmployeeCheckInOutDetailsRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;

    constructor(data?: IGetEmployeeCheckInOutDetailsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeeCheckInOutDetailsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeCheckInOutDetailsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data; 
    }
}

export interface IGetEmployeeCheckInOutDetailsRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;
}

export class GetEmployeeCheckInOutDetailsResponse implements IGetEmployeeCheckInOutDetailsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeCheckInOutDetails?: EmployeeCheckInOutDetailsDto[] | undefined;
    totalCount?: number;

    constructor(data?: IGetEmployeeCheckInOutDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employeeCheckInOutDetails"])) {
                this.employeeCheckInOutDetails = [] as any;
                for (let item of _data["employeeCheckInOutDetails"])
                    this.employeeCheckInOutDetails!.push(EmployeeCheckInOutDetailsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetEmployeeCheckInOutDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeCheckInOutDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employeeCheckInOutDetails)) {
            data["employeeCheckInOutDetails"] = [];
            for (let item of this.employeeCheckInOutDetails)
                data["employeeCheckInOutDetails"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IGetEmployeeCheckInOutDetailsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeCheckInOutDetails?: EmployeeCheckInOutDetailsDto[] | undefined;
    totalCount?: number;
}

export class GetEmployeeForAttendanceResponse implements IGetEmployeeForAttendanceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employees?: EmployeeForAttendanceDto[] | undefined;

    constructor(data?: IGetEmployeeForAttendanceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeForAttendanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEmployeeForAttendanceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeForAttendanceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEmployeeForAttendanceResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employees?: EmployeeForAttendanceDto[] | undefined;
}

export class GetEmployeeLeaveApplicationRequest implements IGetEmployeeLeaveApplicationRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;

    constructor(data?: IGetEmployeeLeaveApplicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeeLeaveApplicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeLeaveApplicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data; 
    }
}

export interface IGetEmployeeLeaveApplicationRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;
}

export class GetEmployeeLeaveApplicationResponse implements IGetEmployeeLeaveApplicationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeLeaves?: EmployeeLeavesDto[] | undefined;
    totalCount?: number;

    constructor(data?: IGetEmployeeLeaveApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employeeLeaves"])) {
                this.employeeLeaves = [] as any;
                for (let item of _data["employeeLeaves"])
                    this.employeeLeaves!.push(EmployeeLeavesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetEmployeeLeaveApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeLeaveApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employeeLeaves)) {
            data["employeeLeaves"] = [];
            for (let item of this.employeeLeaves)
                data["employeeLeaves"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IGetEmployeeLeaveApplicationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeLeaves?: EmployeeLeavesDto[] | undefined;
    totalCount?: number;
}

export class GetEmployeeTimeOffApplicationRequest implements IGetEmployeeTimeOffApplicationRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;

    constructor(data?: IGetEmployeeTimeOffApplicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeeTimeOffApplicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTimeOffApplicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data; 
    }
}

export interface IGetEmployeeTimeOffApplicationRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    employeeIds?: number[] | undefined;
}

export class GetEmployeeTimeOffApplicationResponse implements IGetEmployeeTimeOffApplicationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeTimeOffs?: EmployeeTimeOffDto[] | undefined;
    totalCount?: number;

    constructor(data?: IGetEmployeeTimeOffApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["employeeTimeOffs"])) {
                this.employeeTimeOffs = [] as any;
                for (let item of _data["employeeTimeOffs"])
                    this.employeeTimeOffs!.push(EmployeeTimeOffDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetEmployeeTimeOffApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTimeOffApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.employeeTimeOffs)) {
            data["employeeTimeOffs"] = [];
            for (let item of this.employeeTimeOffs)
                data["employeeTimeOffs"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IGetEmployeeTimeOffApplicationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    employeeTimeOffs?: EmployeeTimeOffDto[] | undefined;
    totalCount?: number;
}

export class GetInProgressTimeSheetResponse implements IGetInProgressTimeSheetResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    timeSheet?: TaskTimeSheetDto;

    constructor(data?: IGetInProgressTimeSheetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.timeSheet = _data["timeSheet"] ? TaskTimeSheetDto.fromJS(_data["timeSheet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetInProgressTimeSheetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetInProgressTimeSheetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["timeSheet"] = this.timeSheet ? this.timeSheet.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetInProgressTimeSheetResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    timeSheet?: TaskTimeSheetDto;
}

export class GetResourceTaskScheduleRequest implements IGetResourceTaskScheduleRequest {
    taskId?: number;
    resourceId?: number;

    constructor(data?: IGetResourceTaskScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.resourceId = _data["resourceId"];
        }
    }

    static fromJS(data: any): GetResourceTaskScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetResourceTaskScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["resourceId"] = this.resourceId;
        return data; 
    }
}

export interface IGetResourceTaskScheduleRequest {
    taskId?: number;
    resourceId?: number;
}

export class GetResourceTaskScheduleResponse implements IGetResourceTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    resourceSchedule?: ResourceTaskScheduleDto[] | undefined;

    constructor(data?: IGetResourceTaskScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["resourceSchedule"])) {
                this.resourceSchedule = [] as any;
                for (let item of _data["resourceSchedule"])
                    this.resourceSchedule!.push(ResourceTaskScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetResourceTaskScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetResourceTaskScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.resourceSchedule)) {
            data["resourceSchedule"] = [];
            for (let item of this.resourceSchedule)
                data["resourceSchedule"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetResourceTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    resourceSchedule?: ResourceTaskScheduleDto[] | undefined;
}

export class GetRoleListResponse implements IGetRoleListResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    roles?: RoleDto[] | undefined;

    constructor(data?: IGetRoleListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRoleListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRoleListResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    roles?: RoleDto[] | undefined;
}

export class GetRolesRequest implements IGetRolesRequest {
    pageSize?: number;
    currentPage?: number;

    constructor(data?: IGetRolesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
        }
    }

    static fromJS(data: any): GetRolesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        return data; 
    }
}

export interface IGetRolesRequest {
    pageSize?: number;
    currentPage?: number;
}

export class GetRoleWithPermissionRequest implements IGetRoleWithPermissionRequest {
    id?: number;

    constructor(data?: IGetRoleWithPermissionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetRoleWithPermissionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleWithPermissionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetRoleWithPermissionRequest {
    id?: number;
}

export class GetRoleWithPermissionsResponse implements IGetRoleWithPermissionsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    role?: RoleDto;

    constructor(data?: IGetRoleWithPermissionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoleWithPermissionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleWithPermissionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRoleWithPermissionsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    role?: RoleDto;
}

export class GetSingleProjectResponse implements IGetSingleProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: ProjectDto;

    constructor(data?: IGetSingleProjectResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.project = _data["project"] ? ProjectDto.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSingleProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSingleProjectResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSingleProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: ProjectDto;
}

export class GetTaskLinksRespone implements IGetTaskLinksRespone {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    links?: TaskLinkDto[] | undefined;

    constructor(data?: IGetTaskLinksRespone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(TaskLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTaskLinksRespone {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskLinksRespone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTaskLinksRespone {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    links?: TaskLinkDto[] | undefined;
}

export class GetTaskScheduleApprovalRequest implements IGetTaskScheduleApprovalRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    status?: number;
    employees?: number[] | undefined;

    constructor(data?: IGetTaskScheduleApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.status = _data["status"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(item);
            }
        }
    }

    static fromJS(data: any): GetTaskScheduleApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskScheduleApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["status"] = this.status;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item);
        }
        return data; 
    }
}

export interface IGetTaskScheduleApprovalRequest {
    pageSize?: number;
    currentPage?: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    status?: number;
    employees?: number[] | undefined;
}

export class GetTaskScheduleApprovalResponse implements IGetTaskScheduleApprovalResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    approvals?: TaskScheduleApprovalDto[] | undefined;
    totalCount?: number;

    constructor(data?: IGetTaskScheduleApprovalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["approvals"])) {
                this.approvals = [] as any;
                for (let item of _data["approvals"])
                    this.approvals!.push(TaskScheduleApprovalDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetTaskScheduleApprovalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskScheduleApprovalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.approvals)) {
            data["approvals"] = [];
            for (let item of this.approvals)
                data["approvals"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IGetTaskScheduleApprovalResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    approvals?: TaskScheduleApprovalDto[] | undefined;
    totalCount?: number;
}

export class GetTaskTimeSheetForUserRequest implements IGetTaskTimeSheetForUserRequest {
    taskId?: number;
    employeeId?: number;

    constructor(data?: IGetTaskTimeSheetForUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): GetTaskTimeSheetForUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskTimeSheetForUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IGetTaskTimeSheetForUserRequest {
    taskId?: number;
    employeeId?: number;
}

export class GetTaskTimeSheetForUserResonse implements IGetTaskTimeSheetForUserResonse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    taskTimeSheet?: TaskTimeSheetDto[] | undefined;

    constructor(data?: IGetTaskTimeSheetForUserResonse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["taskTimeSheet"])) {
                this.taskTimeSheet = [] as any;
                for (let item of _data["taskTimeSheet"])
                    this.taskTimeSheet!.push(TaskTimeSheetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTaskTimeSheetForUserResonse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskTimeSheetForUserResonse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.taskTimeSheet)) {
            data["taskTimeSheet"] = [];
            for (let item of this.taskTimeSheet)
                data["taskTimeSheet"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTaskTimeSheetForUserResonse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    taskTimeSheet?: TaskTimeSheetDto[] | undefined;
}

export class GetUserTasksRequest implements IGetUserTasksRequest {
    filter?: number;
    searchTerm?: string | undefined;
    employeeId?: number;

    constructor(data?: IGetUserTasksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.searchTerm = _data["searchTerm"];
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): GetUserTasksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserTasksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["searchTerm"] = this.searchTerm;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IGetUserTasksRequest {
    filter?: number;
    searchTerm?: string | undefined;
    employeeId?: number;
}

export class GetUserTasksResponse implements IGetUserTasksResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    tasks?: ResourceTaskScheduleDto[] | undefined;

    constructor(data?: IGetUserTasksResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(ResourceTaskScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserTasksResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserTasksResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserTasksResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    tasks?: ResourceTaskScheduleDto[] | undefined;
}

export class Leave implements ILeave {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    approvedStartDate?: Date | undefined;
    approvedEndDate?: Date | undefined;
    actualStartDate?: Date | undefined;
    actualEndDate?: Date | undefined;
    currentStatus?: LeaveStatus;
    leaveType?: LeaveType;
    isActive?: boolean;
    reason?: string | undefined;
    noOfDays?: number;
    leaveAudits?: LeaveAudit[] | undefined;

    constructor(data?: ILeave) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.approvedStartDate = _data["approvedStartDate"] ? new Date(_data["approvedStartDate"].toString()) : <any>undefined;
            this.approvedEndDate = _data["approvedEndDate"] ? new Date(_data["approvedEndDate"].toString()) : <any>undefined;
            this.actualStartDate = _data["actualStartDate"] ? new Date(_data["actualStartDate"].toString()) : <any>undefined;
            this.actualEndDate = _data["actualEndDate"] ? new Date(_data["actualEndDate"].toString()) : <any>undefined;
            this.currentStatus = _data["currentStatus"];
            this.leaveType = _data["leaveType"];
            this.isActive = _data["isActive"];
            this.reason = _data["reason"];
            this.noOfDays = _data["noOfDays"];
            if (Array.isArray(_data["leaveAudits"])) {
                this.leaveAudits = [] as any;
                for (let item of _data["leaveAudits"])
                    this.leaveAudits!.push(LeaveAudit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Leave {
        data = typeof data === 'object' ? data : {};
        let result = new Leave();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["approvedStartDate"] = this.approvedStartDate ? this.approvedStartDate.toISOString() : <any>undefined;
        data["approvedEndDate"] = this.approvedEndDate ? this.approvedEndDate.toISOString() : <any>undefined;
        data["actualStartDate"] = this.actualStartDate ? this.actualStartDate.toISOString() : <any>undefined;
        data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.toISOString() : <any>undefined;
        data["currentStatus"] = this.currentStatus;
        data["leaveType"] = this.leaveType;
        data["isActive"] = this.isActive;
        data["reason"] = this.reason;
        data["noOfDays"] = this.noOfDays;
        if (Array.isArray(this.leaveAudits)) {
            data["leaveAudits"] = [];
            for (let item of this.leaveAudits)
                data["leaveAudits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILeave {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    approvedStartDate?: Date | undefined;
    approvedEndDate?: Date | undefined;
    actualStartDate?: Date | undefined;
    actualEndDate?: Date | undefined;
    currentStatus?: LeaveStatus;
    leaveType?: LeaveType;
    isActive?: boolean;
    reason?: string | undefined;
    noOfDays?: number;
    leaveAudits?: LeaveAudit[] | undefined;
}

export enum LeaveApprovalType {
    _0 = 0,
    _1 = 1,
}

export class LeaveAudit implements ILeaveAudit {
    id?: number;
    date?: Date | undefined;
    status?: LeaveAuditStatus;
    leaveApprovalType?: LeaveApprovalType;
    approvalRequired?: number;
    actionTakenBy?: number | undefined;
    leaveId?: number;
    leave?: Leave;
    employee?: Employee;

    constructor(data?: ILeaveAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.leaveApprovalType = _data["leaveApprovalType"];
            this.approvalRequired = _data["approvalRequired"];
            this.actionTakenBy = _data["actionTakenBy"];
            this.leaveId = _data["leaveId"];
            this.leave = _data["leave"] ? Leave.fromJS(_data["leave"]) : <any>undefined;
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveAudit {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["leaveApprovalType"] = this.leaveApprovalType;
        data["approvalRequired"] = this.approvalRequired;
        data["actionTakenBy"] = this.actionTakenBy;
        data["leaveId"] = this.leaveId;
        data["leave"] = this.leave ? this.leave.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILeaveAudit {
    id?: number;
    date?: Date | undefined;
    status?: LeaveAuditStatus;
    leaveApprovalType?: LeaveApprovalType;
    approvalRequired?: number;
    actionTakenBy?: number | undefined;
    leaveId?: number;
    leave?: Leave;
    employee?: Employee;
}

export enum LeaveAuditStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class LeaveBank implements ILeaveBank {
    id?: number;
    used?: number;
    balance?: number;
    leaveType?: LeaveType;
    employeeId?: number;
    employee?: Employee;

    constructor(data?: ILeaveBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.used = _data["used"];
            this.balance = _data["balance"];
            this.leaveType = _data["leaveType"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveBank {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveBank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["used"] = this.used;
        data["balance"] = this.balance;
        data["leaveType"] = this.leaveType;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILeaveBank {
    id?: number;
    used?: number;
    balance?: number;
    leaveType?: LeaveType;
    employeeId?: number;
    employee?: Employee;
}

export class LeaveDetailDto implements ILeaveDetailDto {
    id?: number;
    employeeId?: number;
    employeeName?: string | undefined;
    employeeDesignation?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    leaveTypeId?: number;
    reason?: string | undefined;
    leaveType?: string | undefined;
    currentStatus?: string | undefined;

    constructor(data?: ILeaveDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeDesignation = _data["employeeDesignation"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.leaveTypeId = _data["leaveTypeId"];
            this.reason = _data["reason"];
            this.leaveType = _data["leaveType"];
            this.currentStatus = _data["currentStatus"];
        }
    }

    static fromJS(data: any): LeaveDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeDesignation"] = this.employeeDesignation;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveTypeId"] = this.leaveTypeId;
        data["reason"] = this.reason;
        data["leaveType"] = this.leaveType;
        data["currentStatus"] = this.currentStatus;
        return data; 
    }
}

export interface ILeaveDetailDto {
    id?: number;
    employeeId?: number;
    employeeName?: string | undefined;
    employeeDesignation?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    leaveTypeId?: number;
    reason?: string | undefined;
    leaveType?: string | undefined;
    currentStatus?: string | undefined;
}

export class LeaveDetailResponse implements ILeaveDetailResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    leave?: LeaveDetailDto;

    constructor(data?: ILeaveDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.leave = _data["leave"] ? LeaveDetailDto.fromJS(_data["leave"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveDetailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveDetailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["leave"] = this.leave ? this.leave.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILeaveDetailResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    leave?: LeaveDetailDto;
}

export enum LeaveStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum LeaveType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class LoginUserRequest implements ILoginUserRequest {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginUserRequest {
    userName?: string | undefined;
    password?: string | undefined;
}

export class LoginUserResponse implements ILoginUserResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    id?: number;
    email?: string | undefined;
    employeeId?: number;
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: ILoginUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.id = _data["id"];
            this.email = _data["email"];
            this.employeeId = _data["employeeId"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): LoginUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["id"] = this.id;
        data["email"] = this.email;
        data["employeeId"] = this.employeeId;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface ILoginUserResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    id?: number;
    email?: string | undefined;
    employeeId?: number;
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class MarkNotificationViewedRequest implements IMarkNotificationViewedRequest {
    id?: number;

    constructor(data?: IMarkNotificationViewedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MarkNotificationViewedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MarkNotificationViewedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IMarkNotificationViewedRequest {
    id?: number;
}

export class MarkNotificationViewedResponse implements IMarkNotificationViewedResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IMarkNotificationViewedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): MarkNotificationViewedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MarkNotificationViewedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IMarkNotificationViewedResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class MultiprojectTaskAssignmentRequest implements IMultiprojectTaskAssignmentRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    employeeId?: number;
    projectIds?: number[] | undefined;

    constructor(data?: IMultiprojectTaskAssignmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.verb = _data["verb"];
            this.parentTaskId = _data["parentTaskId"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): MultiprojectTaskAssignmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MultiprojectTaskAssignmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["verb"] = this.verb;
        data["parentTaskId"] = this.parentTaskId;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data; 
    }
}

export interface IMultiprojectTaskAssignmentRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    employeeId?: number;
    projectIds?: number[] | undefined;
}

export class MultiprojectTaskAssignmentResponse implements IMultiprojectTaskAssignmentResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IMultiprojectTaskAssignmentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): MultiprojectTaskAssignmentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MultiprojectTaskAssignmentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IMultiprojectTaskAssignmentResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class Notification implements INotification {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    date?: Date;
    type?: NotificationType;
    status?: NotificationStatus;
    for?: number;
    employee?: Employee;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
            this.for = _data["for"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        data["for"] = this.for;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INotification {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    date?: Date;
    type?: NotificationType;
    status?: NotificationStatus;
    for?: number;
    employee?: Employee;
}

export class NotificationDto implements INotificationDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    date?: Date;
    type?: NotificationType;
    status?: NotificationStatus;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.text = _data["text"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        return data; 
    }
}

export interface INotificationDto {
    id?: number;
    title?: string | undefined;
    text?: string | undefined;
    date?: Date;
    type?: NotificationType;
    status?: NotificationStatus;
}

export enum NotificationStatus {
    _1 = 1,
    _2 = 2,
}

export enum NotificationType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Permission implements IPermission {
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermission[] | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPermission {
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermission[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class Project implements IProject {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    plannerId?: string | undefined;
    progress?: number;
    location?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: number;
    createdByEmployee?: Employee;
    tasks?: Task[] | undefined;
    taskLinks?: TaskLink[] | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.plannerId = _data["plannerId"];
            this.progress = _data["progress"];
            this.location = _data["location"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdByEmployee = _data["createdByEmployee"] ? Employee.fromJS(_data["createdByEmployee"]) : <any>undefined;
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(Task.fromJS(item));
            }
            if (Array.isArray(_data["taskLinks"])) {
                this.taskLinks = [] as any;
                for (let item of _data["taskLinks"])
                    this.taskLinks!.push(TaskLink.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["plannerId"] = this.plannerId;
        data["progress"] = this.progress;
        data["location"] = this.location;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdByEmployee"] = this.createdByEmployee ? this.createdByEmployee.toJSON() : <any>undefined;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.taskLinks)) {
            data["taskLinks"] = [];
            for (let item of this.taskLinks)
                data["taskLinks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProject {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    plannerId?: string | undefined;
    progress?: number;
    location?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: number;
    createdByEmployee?: Employee;
    tasks?: Task[] | undefined;
    taskLinks?: TaskLink[] | undefined;
}

export class ProjectDto implements IProjectDto {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    plannerId?: string | undefined;
    createdDate?: Date;
    progress?: number;
    createdBy?: number;
    days?: number;
    tasks?: TaskDto[] | undefined;
    taskLinks?: TaskLinkDto[] | undefined;
    expanded?: boolean | true;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.plannerId = _data["plannerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.createdBy = _data["createdBy"];
            this.days = _data["days"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskDto.fromJS(item));
            }
            if (Array.isArray(_data["taskLinks"])) {
                this.taskLinks = [] as any;
                for (let item of _data["taskLinks"])
                    this.taskLinks!.push(TaskLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["plannerId"] = this.plannerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["createdBy"] = this.createdBy;
        data["days"] = this.days;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        if (Array.isArray(this.taskLinks)) {
            data["taskLinks"] = [];
            for (let item of this.taskLinks)
                data["taskLinks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectDto {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    plannerId?: string | undefined;
    createdDate?: Date;
    progress?: number;
    createdBy?: number;
    days?: number;
    tasks?: TaskDto[] | undefined;
    taskLinks?: TaskLinkDto[] | undefined;
}

export class ProjectWorkLoadDto implements IProjectWorkLoadDto {
    projectId?: number;
    projectName?: string | undefined;
    assignedHours?: number;
    totalHours?: number;

    constructor(data?: IProjectWorkLoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.projectName = _data["projectName"];
            this.assignedHours = _data["assignedHours"];
            this.totalHours = _data["totalHours"];
        }
    }

    static fromJS(data: any): ProjectWorkLoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWorkLoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["assignedHours"] = this.assignedHours;
        data["totalHours"] = this.totalHours;
        return data; 
    }
}

export interface IProjectWorkLoadDto {
    projectId?: number;
    projectName?: string | undefined;
    assignedHours?: number;
    totalHours?: number;
}

export class RegisterUserRequest implements IRegisterUserRequest {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterUserRequest {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class RejectTaskScheduleRequest implements IRejectTaskScheduleRequest {
    scheduleId?: number;

    constructor(data?: IRejectTaskScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
        }
    }

    static fromJS(data: any): RejectTaskScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTaskScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        return data; 
    }
}

export interface IRejectTaskScheduleRequest {
    scheduleId?: number;
}

export class RejectTaskScheduleResponse implements IRejectTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IRejectTaskScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): RejectTaskScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTaskScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IRejectTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class RejectTimeOffRequest implements IRejectTimeOffRequest {
    id?: number;
    comments?: string | undefined;

    constructor(data?: IRejectTimeOffRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): RejectTimeOffRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTimeOffRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IRejectTimeOffRequest {
    id?: number;
    comments?: string | undefined;
}

export class RejectTimeOffResponse implements IRejectTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IRejectTimeOffResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): RejectTimeOffResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RejectTimeOffResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IRejectTimeOffResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class RemoveResourceScheduleRequest implements IRemoveResourceScheduleRequest {
    id?: number;

    constructor(data?: IRemoveResourceScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveResourceScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveResourceScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveResourceScheduleRequest {
    id?: number;
}

export class RemoveResourceScheduleResponse implements IRemoveResourceScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IRemoveResourceScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveResourceScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveResourceScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IRemoveResourceScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class RemoveTaskLinkRequest implements IRemoveTaskLinkRequest {
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
    id?: number;

    constructor(data?: IRemoveTaskLinkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceTaskId = _data["sourceTaskId"];
            this.targetTaskId = _data["targetTaskId"];
            this.projectId = _data["projectId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RemoveTaskLinkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveTaskLinkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceTaskId"] = this.sourceTaskId;
        data["targetTaskId"] = this.targetTaskId;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRemoveTaskLinkRequest {
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
    id?: number;
}

export enum ResourceAssignmentType {
    _1 = 1,
    _2 = 2,
}

export class ResourceScheduleByDatesRequest implements IResourceScheduleByDatesRequest {
    start?: Date;
    end?: Date;
    employeeId?: number;

    constructor(data?: IResourceScheduleByDatesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): ResourceScheduleByDatesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceScheduleByDatesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        return data; 
    }
}

export interface IResourceScheduleByDatesRequest {
    start?: Date;
    end?: Date;
    employeeId?: number;
}

export class ResourceScheduleByDatesResponse implements IResourceScheduleByDatesResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    resourceSchedule?: ResourceTaskScheduleDto[] | undefined;

    constructor(data?: IResourceScheduleByDatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["resourceSchedule"])) {
                this.resourceSchedule = [] as any;
                for (let item of _data["resourceSchedule"])
                    this.resourceSchedule!.push(ResourceTaskScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourceScheduleByDatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceScheduleByDatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.resourceSchedule)) {
            data["resourceSchedule"] = [];
            for (let item of this.resourceSchedule)
                data["resourceSchedule"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResourceScheduleByDatesResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    resourceSchedule?: ResourceTaskScheduleDto[] | undefined;
}

export class ResourceTaskSchedule implements IResourceTaskSchedule {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isInProgress?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
    status?: ResourceTaskScheduleStatus;
    taskResource?: TaskResource;
    taskTimeSheets?: TaskTimeSheet[] | undefined;

    constructor(data?: IResourceTaskSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.allocatedHours = _data["allocatedHours"];
            this.actualHours = _data["actualHours"];
            this.isInProgress = _data["isInProgress"];
            this.isCompleted = _data["isCompleted"];
            this.taskResourceId = _data["taskResourceId"];
            this.status = _data["status"];
            this.taskResource = _data["taskResource"] ? TaskResource.fromJS(_data["taskResource"]) : <any>undefined;
            if (Array.isArray(_data["taskTimeSheets"])) {
                this.taskTimeSheets = [] as any;
                for (let item of _data["taskTimeSheets"])
                    this.taskTimeSheets!.push(TaskTimeSheet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourceTaskSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceTaskSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["allocatedHours"] = this.allocatedHours;
        data["actualHours"] = this.actualHours;
        data["isInProgress"] = this.isInProgress;
        data["isCompleted"] = this.isCompleted;
        data["taskResourceId"] = this.taskResourceId;
        data["status"] = this.status;
        data["taskResource"] = this.taskResource ? this.taskResource.toJSON() : <any>undefined;
        if (Array.isArray(this.taskTimeSheets)) {
            data["taskTimeSheets"] = [];
            for (let item of this.taskTimeSheets)
                data["taskTimeSheets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResourceTaskSchedule {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isInProgress?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
    status?: ResourceTaskScheduleStatus;
    taskResource?: TaskResource;
    taskTimeSheets?: TaskTimeSheet[] | undefined;
}

export class ResourceTaskScheduleDto implements IResourceTaskScheduleDto {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isInProgress?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
    taskName?: string | undefined;
    projectName?: string | undefined;

    constructor(data?: IResourceTaskScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.allocatedHours = _data["allocatedHours"];
            this.actualHours = _data["actualHours"];
            this.isInProgress = _data["isInProgress"];
            this.isCompleted = _data["isCompleted"];
            this.taskResourceId = _data["taskResourceId"];
            this.taskName = _data["taskName"];
            this.projectName = _data["projectName"];
        }
    }

    static fromJS(data: any): ResourceTaskScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceTaskScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["allocatedHours"] = this.allocatedHours;
        data["actualHours"] = this.actualHours;
        data["isInProgress"] = this.isInProgress;
        data["isCompleted"] = this.isCompleted;
        data["taskResourceId"] = this.taskResourceId;
        data["taskName"] = this.taskName;
        data["projectName"] = this.projectName;
        return data; 
    }
}

export interface IResourceTaskScheduleDto {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isInProgress?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
    taskName?: string | undefined;
    projectName?: string | undefined;
}

export enum ResourceTaskScheduleStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Role implements IRole {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermission[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermission[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class RoleDto implements IRoleDto {
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermissionDto[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleDto {
    id?: number;
    name?: string | undefined;
    rolePermissions?: RolePermissionDto[] | undefined;
}

export class RolePermission implements IRolePermission {
    permissionId?: number;
    roleId?: number;
    permission?: Permission;
    role?: Role;

    constructor(data?: IRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.roleId = _data["roleId"];
            this.permission = _data["permission"] ? Permission.fromJS(_data["permission"]) : <any>undefined;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["roleId"] = this.roleId;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRolePermission {
    permissionId?: number;
    roleId?: number;
    permission?: Permission;
    role?: Role;
}

export class RolePermissionDto implements IRolePermissionDto {
    permissionId?: number;
    roleId?: number;

    constructor(data?: IRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): RolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export interface IRolePermissionDto {
    permissionId?: number;
    roleId?: number;
}

export class SimpleProjectDto implements ISimpleProjectDto {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    location?: string | undefined;
    createdByEmployee?: string | undefined;
    plannerId?: string | undefined;

    constructor(data?: ISimpleProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.location = _data["location"];
            this.createdByEmployee = _data["createdByEmployee"];
            this.plannerId = _data["plannerId"];
        }
    }

    static fromJS(data: any): SimpleProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["location"] = this.location;
        data["createdByEmployee"] = this.createdByEmployee;
        data["plannerId"] = this.plannerId;
        return data; 
    }
}

export interface ISimpleProjectDto {
    id?: number;
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    location?: string | undefined;
    createdByEmployee?: string | undefined;
    plannerId?: string | undefined;
}

export class Task implements ITask {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    completedDate?: Date | undefined;
    isCompleted?: boolean;
    taskType?: TaskType;
    isActive?: boolean;
    parentTaskId?: number | undefined;
    projectId?: number;
    project?: Project;
    resources?: TaskResource[] | undefined;
    taskNavigation?: Task;
    tasks?: Task[] | undefined;
    levelDetailList: any;


    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.verb = _data["verb"];
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            this.taskType = _data["taskType"];
            this.isActive = _data["isActive"];
            this.parentTaskId = _data["parentTaskId"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(TaskResource.fromJS(item));
            }
            this.taskNavigation = _data["taskNavigation"] ? Task.fromJS(_data["taskNavigation"]) : <any>undefined;
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(Task.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["verb"] = this.verb;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["taskType"] = this.taskType;
        data["isActive"] = this.isActive;
        data["parentTaskId"] = this.parentTaskId;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        data["taskNavigation"] = this.taskNavigation ? this.taskNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITask {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    completedDate?: Date | undefined;
    isCompleted?: boolean;
    taskType?: TaskType;
    isActive?: boolean;
    parentTaskId?: number | undefined;
    projectId?: number;
    project?: Project;
    resources?: TaskResource[] | undefined;
    taskNavigation?: Task;
    tasks?: Task[] | undefined;
}

export class TaskCheckInDto implements ITaskCheckInDto {
    id?: number;
    checkIn?: Date;
    checkOut?: Date;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    taskResourceId?: number;

    constructor(data?: ITaskCheckInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkIn = _data["checkIn"] ? new Date(_data["checkIn"].toString()) : <any>undefined;
            this.checkOut = _data["checkOut"] ? new Date(_data["checkOut"].toString()) : <any>undefined;
            this.checkInLocation = _data["checkInLocation"];
            this.checkOutLocation = _data["checkOutLocation"];
            this.taskResourceId = _data["taskResourceId"];
        }
    }

    static fromJS(data: any): TaskCheckInDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCheckInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkIn"] = this.checkIn ? this.checkIn.toISOString() : <any>undefined;
        data["checkOut"] = this.checkOut ? this.checkOut.toISOString() : <any>undefined;
        data["checkInLocation"] = this.checkInLocation;
        data["checkOutLocation"] = this.checkOutLocation;
        data["taskResourceId"] = this.taskResourceId;
        return data; 
    }
}

export interface ITaskCheckInDto {
    id?: number;
    checkIn?: Date;
    checkOut?: Date;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    taskResourceId?: number;
}

export class TaskCheckInRequest implements ITaskCheckInRequest {
    checkInLocation?: string | undefined;
    resourceTaskScheduleId?: number;
    checkInNotes?: string | undefined;

    constructor(data?: ITaskCheckInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkInLocation = _data["checkInLocation"];
            this.resourceTaskScheduleId = _data["resourceTaskScheduleId"];
            this.checkInNotes = _data["checkInNotes"];
        }
    }

    static fromJS(data: any): TaskCheckInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCheckInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkInLocation"] = this.checkInLocation;
        data["resourceTaskScheduleId"] = this.resourceTaskScheduleId;
        data["checkInNotes"] = this.checkInNotes;
        return data; 
    }
}

export interface ITaskCheckInRequest {
    checkInLocation?: string | undefined;
    resourceTaskScheduleId?: number;
    checkInNotes?: string | undefined;
}

export class TaskCheckInResponse implements ITaskCheckInResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    checkIn?: TaskCheckInDto;

    constructor(data?: ITaskCheckInResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.checkIn = _data["checkIn"] ? TaskCheckInDto.fromJS(_data["checkIn"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskCheckInResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCheckInResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["checkIn"] = this.checkIn ? this.checkIn.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITaskCheckInResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    checkIn?: TaskCheckInDto;
}

export class TaskCheckOutRequest implements ITaskCheckOutRequest {
    id?: number;
    checkOutLocation?: string | undefined;
    isCompleted?: boolean;
    resourceTaskScheduleId?: number;
    checkOutNotes?: string | undefined;

    constructor(data?: ITaskCheckOutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkOutLocation = _data["checkOutLocation"];
            this.isCompleted = _data["isCompleted"];
            this.resourceTaskScheduleId = _data["resourceTaskScheduleId"];
            this.checkOutNotes = _data["checkOutNotes"];
        }
    }

    static fromJS(data: any): TaskCheckOutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCheckOutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkOutLocation"] = this.checkOutLocation;
        data["isCompleted"] = this.isCompleted;
        data["resourceTaskScheduleId"] = this.resourceTaskScheduleId;
        data["checkOutNotes"] = this.checkOutNotes;
        return data; 
    }
}

export interface ITaskCheckOutRequest {
    id?: number;
    checkOutLocation?: string | undefined;
    isCompleted?: boolean;
    resourceTaskScheduleId?: number;
    checkOutNotes?: string | undefined;
}

export class TaskCheckOutResponse implements ITaskCheckOutResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: ITaskCheckOutResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): TaskCheckOutResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCheckOutResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface ITaskCheckOutResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class TaskDto implements ITaskDto {
    id?: number;
    isActive?: boolean;
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    days?: number;
    verb?: string | undefined;
    completedDate?: Date;
    createdDate?: Date;
    taskType?: string | undefined;
    parentTaskId?: number | undefined;
    createdBy?: number;
    projectId?: number;
    start?: number;
    end?: number;
    resources?: TaskResourceDto[] | undefined;
    tasks?: TaskDto[] | undefined;
    expanded?: boolean | true;

    constructor(data?: ITaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.days = _data["days"];
            this.verb = _data["verb"];
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.taskType = _data["taskType"];
            this.parentTaskId = _data["parentTaskId"];
            this.createdBy = _data["createdBy"];
            this.projectId = _data["projectId"];
            this.start = _data["start"];
            this.end = _data["end"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(TaskResourceDto.fromJS(item));
            }
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(TaskDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["days"] = this.days;
        data["verb"] = this.verb;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["taskType"] = this.taskType;
        data["parentTaskId"] = this.parentTaskId;
        data["createdBy"] = this.createdBy;
        data["projectId"] = this.projectId;
        data["start"] = this.start;
        data["end"] = this.end;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITaskDto {
    id?: number;
    isActive?: boolean;
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    days?: number;
    verb?: string | undefined;
    completedDate?: Date;
    createdDate?: Date;
    taskType?: string | undefined;
    parentTaskId?: number | undefined;
    createdBy?: number;
    projectId?: number;
    start?: number;
    end?: number;
    resources?: TaskResourceDto[] | undefined;
    tasks?: TaskDto[] | undefined;
}

export class TaskLink implements ITaskLink {
    id?: number;
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
    project?: Project;

    constructor(data?: ITaskLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceTaskId = _data["sourceTaskId"];
            this.targetTaskId = _data["targetTaskId"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskLink {
        data = typeof data === 'object' ? data : {};
        let result = new TaskLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceTaskId"] = this.sourceTaskId;
        data["targetTaskId"] = this.targetTaskId;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITaskLink {
    id?: number;
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
    project?: Project;
}

export class TaskLinkDto implements ITaskLinkDto {
    id?: number;
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;

    constructor(data?: ITaskLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceTaskId = _data["sourceTaskId"];
            this.targetTaskId = _data["targetTaskId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): TaskLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceTaskId"] = this.sourceTaskId;
        data["targetTaskId"] = this.targetTaskId;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface ITaskLinkDto {
    id?: number;
    sourceTaskId?: number;
    targetTaskId?: number;
    projectId?: number;
}

export class TaskResource implements ITaskResource {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    taskId?: number;
    task?: Task;
    employeeId?: number;
    employee?: Employee;
    resourceTaskSchedules?: ResourceTaskSchedule[] | undefined;

    constructor(data?: ITaskResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.taskId = _data["taskId"];
            this.task = _data["task"] ? Task.fromJS(_data["task"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            if (Array.isArray(_data["resourceTaskSchedules"])) {
                this.resourceTaskSchedules = [] as any;
                for (let item of _data["resourceTaskSchedules"])
                    this.resourceTaskSchedules!.push(ResourceTaskSchedule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskResource {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["taskId"] = this.taskId;
        data["task"] = this.task ? this.task.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        if (Array.isArray(this.resourceTaskSchedules)) {
            data["resourceTaskSchedules"] = [];
            for (let item of this.resourceTaskSchedules)
                data["resourceTaskSchedules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITaskResource {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    taskId?: number;
    task?: Task;
    employeeId?: number;
    employee?: Employee;
    resourceTaskSchedules?: ResourceTaskSchedule[] | undefined;
}

export class TaskResourceDto implements ITaskResourceDto {
    taskId?: number;
    employeeId?: number;
    name?: string | undefined;
    departmentId?: number;

    constructor(data?: ITaskResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): TaskResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["departmentId"] = this.departmentId;
        return data; 
    }
}

export interface ITaskResourceDto {
    taskId?: number;
    employeeId?: number;
    name?: string | undefined;
    departmentId?: number;
}

export class TaskScheduleApprovalDto implements ITaskScheduleApprovalDto {
    employee?: string | undefined;
    name?: string | undefined;
    id?: number;
    startDate?: Date;
    status?: number;
    allocatedHours?: number;
    actualHours?: number;
    checkInDiff?: number;
    checkOutDiff?: number;

    constructor(data?: ITaskScheduleApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee = _data["employee"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.allocatedHours = _data["allocatedHours"];
            this.actualHours = _data["actualHours"];
            this.checkInDiff = _data["checkInDiff"];
            this.checkOutDiff = _data["checkOutDiff"];
        }
    }

    static fromJS(data: any): TaskScheduleApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskScheduleApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee"] = this.employee;
        data["name"] = this.name;
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["allocatedHours"] = this.allocatedHours;
        data["actualHours"] = this.actualHours;
        data["checkInDiff"] = this.checkInDiff;
        data["checkOutDiff"] = this.checkOutDiff;
        return data; 
    }
}

export interface ITaskScheduleApprovalDto {
    employee?: string | undefined;
    name?: string | undefined;
    id?: number;
    startDate?: Date;
    status?: number;
    allocatedHours?: number;
    actualHours?: number;
    checkInDiff?: number;
    checkOutDiff?: number;
}

export class TaskTimeSheet implements ITaskTimeSheet {
    id?: number;
    checkIn?: Date;
    checkInNotes?: string | undefined;
    checkOut?: Date;
    checkOutNotes?: string | undefined;
    checkInLocation?: string | undefined;
    checkInLocDiff?: number;
    checkOutLocation?: string | undefined;
    checkOutLocDiff?: number;
    minutes?: number;
    isInProgress?: boolean;
    resourceTaskScheduleId?: number;
    resourceTaskSchedule?: ResourceTaskSchedule;

    constructor(data?: ITaskTimeSheet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkIn = _data["checkIn"] ? new Date(_data["checkIn"].toString()) : <any>undefined;
            this.checkInNotes = _data["checkInNotes"];
            this.checkOut = _data["checkOut"] ? new Date(_data["checkOut"].toString()) : <any>undefined;
            this.checkOutNotes = _data["checkOutNotes"];
            this.checkInLocation = _data["checkInLocation"];
            this.checkInLocDiff = _data["checkInLocDiff"];
            this.checkOutLocation = _data["checkOutLocation"];
            this.checkOutLocDiff = _data["checkOutLocDiff"];
            this.minutes = _data["minutes"];
            this.isInProgress = _data["isInProgress"];
            this.resourceTaskScheduleId = _data["resourceTaskScheduleId"];
            this.resourceTaskSchedule = _data["resourceTaskSchedule"] ? ResourceTaskSchedule.fromJS(_data["resourceTaskSchedule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskTimeSheet {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTimeSheet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkIn"] = this.checkIn ? this.checkIn.toISOString() : <any>undefined;
        data["checkInNotes"] = this.checkInNotes;
        data["checkOut"] = this.checkOut ? this.checkOut.toISOString() : <any>undefined;
        data["checkOutNotes"] = this.checkOutNotes;
        data["checkInLocation"] = this.checkInLocation;
        data["checkInLocDiff"] = this.checkInLocDiff;
        data["checkOutLocation"] = this.checkOutLocation;
        data["checkOutLocDiff"] = this.checkOutLocDiff;
        data["minutes"] = this.minutes;
        data["isInProgress"] = this.isInProgress;
        data["resourceTaskScheduleId"] = this.resourceTaskScheduleId;
        data["resourceTaskSchedule"] = this.resourceTaskSchedule ? this.resourceTaskSchedule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITaskTimeSheet {
    id?: number;
    checkIn?: Date;
    checkInNotes?: string | undefined;
    checkOut?: Date;
    checkOutNotes?: string | undefined;
    checkInLocation?: string | undefined;
    checkInLocDiff?: number;
    checkOutLocation?: string | undefined;
    checkOutLocDiff?: number;
    minutes?: number;
    isInProgress?: boolean;
    resourceTaskScheduleId?: number;
    resourceTaskSchedule?: ResourceTaskSchedule;
}

export class TaskTimeSheetDto implements ITaskTimeSheetDto {
    id?: number;
    checkIn?: Date;
    checkInNotes?: string | undefined;
    checkOut?: Date;
    checkOutNotes?: string | undefined;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    taskResourceId?: number;
    isInProgress?: boolean;

    constructor(data?: ITaskTimeSheetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkIn = _data["checkIn"] ? new Date(_data["checkIn"].toString()) : <any>undefined;
            this.checkInNotes = _data["checkInNotes"];
            this.checkOut = _data["checkOut"] ? new Date(_data["checkOut"].toString()) : <any>undefined;
            this.checkOutNotes = _data["checkOutNotes"];
            this.checkInLocation = _data["checkInLocation"];
            this.checkOutLocation = _data["checkOutLocation"];
            this.taskResourceId = _data["taskResourceId"];
            this.isInProgress = _data["isInProgress"];
        }
    }

    static fromJS(data: any): TaskTimeSheetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTimeSheetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkIn"] = this.checkIn ? this.checkIn.toISOString() : <any>undefined;
        data["checkInNotes"] = this.checkInNotes;
        data["checkOut"] = this.checkOut ? this.checkOut.toISOString() : <any>undefined;
        data["checkOutNotes"] = this.checkOutNotes;
        data["checkInLocation"] = this.checkInLocation;
        data["checkOutLocation"] = this.checkOutLocation;
        data["taskResourceId"] = this.taskResourceId;
        data["isInProgress"] = this.isInProgress;
        return data; 
    }
}

export interface ITaskTimeSheetDto {
    id?: number;
    checkIn?: Date;
    checkInNotes?: string | undefined;
    checkOut?: Date;
    checkOutNotes?: string | undefined;
    checkInLocation?: string | undefined;
    checkOutLocation?: string | undefined;
    taskResourceId?: number;
    isInProgress?: boolean;
}

export enum TaskType {
    _1 = 1,
    _2 = 2,
}

export class TimeOff implements ITimeOff {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    start?: Date;
    end?: Date;
    reason?: string | undefined;
    comments?: string | undefined;
    status?: TimeOffStatus;
    approvalDate?: Date | undefined;
    isActive?: boolean;
    approvedBy?: number | undefined;
    approvedByEmp?: Employee;

    constructor(data?: ITimeOff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.createdByEmp = _data["createdByEmp"] ? Employee.fromJS(_data["createdByEmp"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.modifiedByEmp = _data["modifiedByEmp"] ? Employee.fromJS(_data["modifiedByEmp"]) : <any>undefined;
            this.id = _data["id"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.reason = _data["reason"];
            this.comments = _data["comments"];
            this.status = _data["status"];
            this.approvalDate = _data["approvalDate"] ? new Date(_data["approvalDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByEmp = _data["approvedByEmp"] ? Employee.fromJS(_data["approvedByEmp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeOff {
        data = typeof data === 'object' ? data : {};
        let result = new TimeOff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdByEmp"] = this.createdByEmp ? this.createdByEmp.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["modifiedByEmp"] = this.modifiedByEmp ? this.modifiedByEmp.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        data["comments"] = this.comments;
        data["status"] = this.status;
        data["approvalDate"] = this.approvalDate ? this.approvalDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["approvedBy"] = this.approvedBy;
        data["approvedByEmp"] = this.approvedByEmp ? this.approvedByEmp.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITimeOff {
    createdBy?: number | undefined;
    createdDate?: Date;
    createdByEmp?: Employee;
    modifiedBy?: number | undefined;
    modifiedDate?: Date;
    modifiedByEmp?: Employee;
    id?: number;
    start?: Date;
    end?: Date;
    reason?: string | undefined;
    comments?: string | undefined;
    status?: TimeOffStatus;
    approvalDate?: Date | undefined;
    isActive?: boolean;
    approvedBy?: number | undefined;
    approvedByEmp?: Employee;
}

export enum TimeOffStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class UpdateProjectRequest implements IUpdateProjectRequest {
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    location?: string | undefined;
    id?: number;

    constructor(data?: IUpdateProjectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.location = _data["location"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateProjectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateProjectRequest {
    projectCode?: string | undefined;
    projectName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    location?: string | undefined;
    id?: number;
}

export class UpdateProjectResponse implements IUpdateProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: SimpleProjectDto;

    constructor(data?: IUpdateProjectResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.project = _data["project"] ? SimpleProjectDto.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateProjectResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    project?: SimpleProjectDto;
}

export class UpdateResourceTaskScheduleDto implements IUpdateResourceTaskScheduleDto {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isStarted?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;

    constructor(data?: IUpdateResourceTaskScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.allocatedHours = _data["allocatedHours"];
            this.actualHours = _data["actualHours"];
            this.isStarted = _data["isStarted"];
            this.isCompleted = _data["isCompleted"];
            this.taskResourceId = _data["taskResourceId"];
        }
    }

    static fromJS(data: any): UpdateResourceTaskScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceTaskScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["allocatedHours"] = this.allocatedHours;
        data["actualHours"] = this.actualHours;
        data["isStarted"] = this.isStarted;
        data["isCompleted"] = this.isCompleted;
        data["taskResourceId"] = this.taskResourceId;
        return data; 
    }
}

export interface IUpdateResourceTaskScheduleDto {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isStarted?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
}

export class UpdateResourceTaskScheduleRequest implements IUpdateResourceTaskScheduleRequest {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isStarted?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;

    constructor(data?: IUpdateResourceTaskScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.allocatedHours = _data["allocatedHours"];
            this.actualHours = _data["actualHours"];
            this.isStarted = _data["isStarted"];
            this.isCompleted = _data["isCompleted"];
            this.taskResourceId = _data["taskResourceId"];
        }
    }

    static fromJS(data: any): UpdateResourceTaskScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceTaskScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["allocatedHours"] = this.allocatedHours;
        data["actualHours"] = this.actualHours;
        data["isStarted"] = this.isStarted;
        data["isCompleted"] = this.isCompleted;
        data["taskResourceId"] = this.taskResourceId;
        return data; 
    }
}

export interface IUpdateResourceTaskScheduleRequest {
    id?: number;
    startDate?: Date;
    endDate?: Date;
    completedDate?: Date;
    allocatedHours?: number;
    actualHours?: number;
    isStarted?: boolean;
    isCompleted?: boolean;
    taskResourceId?: number;
}

export class UpdateResourceTaskScheduleResponse implements IUpdateResourceTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    schedule?: UpdateResourceTaskScheduleDto;

    constructor(data?: IUpdateResourceTaskScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.schedule = _data["schedule"] ? UpdateResourceTaskScheduleDto.fromJS(_data["schedule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateResourceTaskScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceTaskScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateResourceTaskScheduleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    schedule?: UpdateResourceTaskScheduleDto;
}

export class UpdateRolePermissionsRequest implements IUpdateRolePermissionsRequest {
    role?: RoleDto;

    constructor(data?: IUpdateRolePermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRolePermissionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateRolePermissionsRequest {
    role?: RoleDto;
}

export class UpdateRolePermissionsResponse implements IUpdateRolePermissionsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IUpdateRolePermissionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolePermissionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRolePermissionsResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class UpdateRoleRequest implements IUpdateRoleRequest {
    id?: number;
    name?: string | undefined;

    constructor(data?: IUpdateRoleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateRoleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateRoleRequest {
    id?: number;
    name?: string | undefined;
}

export class UpdateRoleResponse implements IUpdateRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IUpdateRoleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRoleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRoleResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class UpdateTaskRequest implements IUpdateTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    id?: number;
    projectId?: number;

    constructor(data?: IUpdateTaskRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.duration = _data["duration"];
            this.verb = _data["verb"];
            this.parentTaskId = _data["parentTaskId"];
            this.id = _data["id"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): UpdateTaskRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["duration"] = this.duration;
        data["verb"] = this.verb;
        data["parentTaskId"] = this.parentTaskId;
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        return data; 
    }
}

export interface IUpdateTaskRequest {
    name?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    progress?: number;
    duration?: number;
    verb?: string | undefined;
    parentTaskId?: number | undefined;
    id?: number;
    projectId?: number;
}

export class UpdateTaskResponse implements IUpdateTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IUpdateTaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateTaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data; 
    }
}

export interface IUpdateTaskResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
}

export class User implements IUser {
    id?: number;
    email?: string | undefined;
    passwordHash?: string | undefined;
    passwordSalt?: string | undefined;
    employee?: Employee;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.passwordHash = _data["passwordHash"];
            this.passwordSalt = _data["passwordSalt"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["passwordHash"] = this.passwordHash;
        data["passwordSalt"] = this.passwordSalt;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    id?: number;
    email?: string | undefined;
    passwordHash?: string | undefined;
    passwordSalt?: string | undefined;
    employee?: Employee;
    userRoles?: UserRole[] | undefined;
}

export class UserNotificationRequest implements IUserNotificationRequest {
    start?: Date | undefined;
    end?: Date | undefined;
    pageSize?: number;
    currentPage?: number;
    status?: NotificationStatus;

    constructor(data?: IUserNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UserNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUserNotificationRequest {
    start?: Date | undefined;
    end?: Date | undefined;
    pageSize?: number;
    currentPage?: number;
    status?: NotificationStatus;
}

export class UserNotificationResponse implements IUserNotificationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    notifications?: NotificationDto[] | undefined;

    constructor(data?: IUserNotificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.successMessage = _data["successMessage"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserNotificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["successMessage"] = this.successMessage;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserNotificationResponse {
    errorMessage?: string | undefined;
    successMessage?: string | undefined;
    validationErrors?: string[] | undefined;
    notifications?: NotificationDto[] | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserRole {
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}